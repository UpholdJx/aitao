<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[PDO使用]]></title>
    <url>%2Faitao%2F2018%2F11%2F09%2FPDO%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[PDO(php data object) 数据库访问抽象层,PDO可以访问12种不同的数据库 开启PDO步骤:找到php.ini 、开启:pod_myql_dll扩展 、重启apache 、验证是否登录成功 PDO 主要类别 PDO类:主要用户数据库连接,发送sql语句PDOStatement类:主要用来解释结果集,实现预处理,事物处理PDOException类:主要用于捕获PDO异常 开始连接123456789$dns = 'mysql:dbname=demo;host=localhost;port=3306'; //数据源名称 本文使用MySQL$username = 'root';//数据库账号$password = 'root';//数据库密码try &#123; $pdo = new PDO($dns, $username, $password);&#125;catch(PDOException $e) &#123; die('数据库连接失败：&lt;br/&gt;' . $e);&#125;$pdo-&gt;setAttribute(PDO::ATTR_EMULATE_PREPARES,false);//选择连接失败的时候处理异常 查询–execute例如:检测用户登录 –校验用户名密码是否匹配，密码使用MD5加密。 query用来处理有结果集的，如select， 返回 PDOStatement 对象，失败返回false（当为 PDO::ERRMODE_SILENT，这也是默认的值）exec用来处理有返回影响行数的（int），如 insert（插入的行数）、 delete（删除的行数） 、update（和原数值不等才算）， 失败返回false （当为 PDO::ERRMODE_SILENT，这也是默认的值）prepare 执行所有sql，可以完全替代 query,exec的功能 12345678910$sql ='SELECT * FROM `user` WHERE `name`=:username AND `password`=:password';$stmt = $pdo-&gt;prepare($sql);$password = $md5($password);$stmt -&gt;bindParam(':username',$username);//绑定参数$stmt -&gt;bindParam(':password',$password);$stmt-&gt;execute();$user = $stmt-&gt;fetch(PDO::FETCH_ASSOC);if(empty($user)) &#123; throw new MyHttpException(500, '用户名或密码错误');//抛出异常&#125; pdo中有两种占位符号 1、? 参数 — 索引数组， 按索引顺序使用 2、名子参数 —-关联数组， 按名称使用，和顺序无关当使用占位符的时候需要绑定参数，如果使用?的适合数组下标必须从0开始，例子如下:123456789101112131415$sql = &apos;INSERT INTO `user` VALUES(null,?,?)&apos;;$stmt = $pdo-&gt;prepare($sql);$data = [ 0=&gt;&apos;username&apos;, 1=&gt;&apos;password&apos;,];$pdo-&gt;beginTransaction(); //开启事物$stmt-&gt;execute($data);$result[&apos;user_id&apos;] = $pdo-&gt;lastInsertId(); //最后插入的id,有多条时返回的是第一条的idif(!empty($result[&apos;user_id&apos;])) &#123; $pdo-&gt;commit();//插入成功，提交事物&#125;else &#123; $pdo-&gt;rollBack(); //插入失败，回滚事物 throw new MyHttpException(500, &apos;插入失败&apos;);//抛出异常&#125; 查询单条记录的时候可以使用 fetch(PDO::FETCH_ASSOC);当查询有多条记录的时候使用 fetchAll(PDO::FETCH_ASSOC); 12345678910111213141516171819202122232425栗子：查询文章详情 --- 单条$sql = 'SELECT * FROM `article` WHERE `id` =:articleId';$stmt = $pdo-&gt;prepare($sql);$createTime = time();$stmt -&gt;bindParam(':articleId',$articleId);$stmt-&gt;execute();$article = $stmt-&gt;fetch(PDO::FETCH_ASSOC);查询多条文章 --- 可以加入分页控制传入的参数 如： $userId,$page=1,$limit=10$sql = 'SELECT * FROM `article` WHERE `user_id`=:userId ORDER BY `id` DESC LIMIT :offset,:limit';$offset = ($page - 1) * $limit;if ($offset &lt; 0)&#123; $offset = 0;&#125;$stmt = $pdo-&gt;prepare($sql);$stmt-&gt;bindParam(':userId', $userId, PDO::PARAM_INT);$stmt-&gt;bindParam(':offset', $offset, PDO::PARAM_INT);$stmt-&gt;bindParam(':limit', $limit, PDO::PARAM_INT);$stmt-&gt;execute();$data = $stmt-&gt;fetchAll(PDO::FETCH_ASSOC); 关于访问其他数据库自行折腾，下面是访问Oracle的感兴趣的可以去看看。php如何利用PDO访问oracle数据库的方法详解本文参考文章思齐博客–PDO 用法学习PHP中文网–PHP之详解PDO]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PDO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHPExcell导入导出相关学习]]></title>
    <url>%2Faitao%2F2018%2F11%2F07%2FPHPExcell%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA%E7%9B%B8%E5%85%B3%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[本项目github 上官方已经放弃维护，官方推荐：PhpSpreadsheet 具体自行尝试。 初始化引入文件123456扩展安装composer require phpoffice/phpexceluse PHPExcel;use PHPExcel_Style_Alignment;//如果需要定义样式需要引入此文件使用$objPHPExcel = new PHPExcel(); 合并拆分单元格12$objPHPExcel-&gt;getActiveSheet()-&gt;mergeCells('A1:A2');//合并单元格$objPHPExcel-&gt;getActiveSheet()-&gt;unmergeCells( 'A28:B28');// A28:B28再拆分 获得合并后的单元格12$mergeInfo = $objPHPExcel-&gt;getActiveSheet()-&gt;getMergeCells();//获得合并后的单元格 格式例如：A1:B1 ... 样式设置1234567891011字体加粗、居中、$objPHPExcel-&gt;getActiveSheet()-&gt;getStyle('A1:X2')-&gt;applyFromArray( array( 'font' =&gt; array ( 'bold' =&gt; true ), 'alignment' =&gt; array ( 'horizontal' =&gt; PHPExcel_Style_Alignment::HORIZONTAL_RIGHT , ), )); 填充背景色123//设置填充的样式和背景色$objPHPExcel-&gt;getActiveSheet()-&gt;getStyle( &apos;A1:E1&apos;)-&gt;getFill()-&gt;setFillType(PHPExcel_Style_Fill::FILL_SOLID);$objPHPExcel-&gt;getActiveSheet()-&gt;getStyle( &apos;A1:E1&apos;)-&gt;getFill()-&gt;getStartColor()-&gt;setARGB(&apos;FF808080&apos;); 设置列的宽度 12$objActSheet-&gt;getColumnDimension( &apos;B&apos;)-&gt;setAutoSize(true); //内容自适应$objActSheet-&gt;getColumnDimension( &apos;A&apos;)-&gt;setWidth(30); //30宽 下载文件123456789$xlsTitle = iconv('utf-8', 'gb2312', '下载文件');//文件名称$fileName = $title.date('_YmdHis');//文件名称header('pragma:public');header('Content-type:application/vnd.ms-excel;charset=utf-8;name="'.$xlsTitle.'.xls"');header("Content-Disposition:attachment;filename=$fileName.xls");//attachment新窗口打印inline本窗口打印$objWriter = \PHPExcel_IOFactory::createWriter($objPHPExcel, 'Excel5');$objWriter-&gt;save('php://output');exit; 导出实例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public function exportExcel($title,$list)&#123;$objPHPExcel = new PHPExcel();$xlsTitle = iconv(&apos;utf-8&apos;, &apos;gb2312&apos;, $title);//文件名称 $fileName = $title.date(&apos;_YmdHis&apos;);//文件名称 $topNumber = 1;//第一行表头 $topNumber2 = 2;//第二行表头 $cellKey = [&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;D&apos;,&apos;E&apos;]; //处理表头标题 $objPHPExcel-&gt;getActiveSheet()-&gt;mergeCells(&apos;A1:A2&apos;); $objPHPExcel-&gt;getActiveSheet()-&gt;mergeCells(&apos;B1:B2&apos;); $data[0] = array(&apos;名称&apos;, &apos;变量&apos;,&apos;数字&apos;); $data[1] = array(&apos;&apos;,&apos;&apos;,&apos;大&apos;, &apos;中&apos;,&apos;小&apos;);$objPHPExcel-&gt;getActiveSheet()-&gt;mergeCells(&apos;C1:E1&apos;); $objPHPExcel-&gt;getActiveSheet()-&gt;getStyle(&apos;A1:E2&apos;)-&gt;applyFromArray( array( &apos;font&apos; =&gt; array ( &apos;bold&apos; =&gt; true ), &apos;alignment&apos; =&gt; array ( &apos;horizontal&apos; =&gt; PHPExcel_Style_Alignment::HORIZONTAL_RIGHT , ), ));//设置表头加粗 foreach ($cellKey as $key =&gt; $value) &#123; $objPHPExcel-&gt;setActiveSheetIndex(0)-&gt;setCellValue($cellKey[$key].$topNumber2, $data[1][$key]);//设置表头数据 &#125; $mergeInfo = $objPHPExcel-&gt;getActiveSheet()-&gt;getMergeCells();//获得合并后的单元格 $new_arr = []; foreach ($mergeInfo as $key =&gt; $value) &#123; $new_arr[] = substr($value,0,2);//分割合并后的单元格 获得单列 &#125; foreach ($new_arr as $key =&gt; $value) &#123; $objPHPExcel-&gt;setActiveSheetIndex(0)-&gt;setCellValue($value, $data[0][$key]);//设置表头数据 &#125; //导出数据模拟 $data_list[0] = [ &apos;name&apos;=&gt;&apos;hhh&apos;, &apos;variable&apos;=&gt;&apos;卫星人&apos;, &apos;large&apos;=&gt;12, &apos;in&apos;=&gt;20, &apos;small&apos;=&gt;222 ]; foreach($data_list as $k=&gt;$v) &#123; $data[$k + 2] = array( $v[&apos;name&apos;], $v[&apos;variable&apos;], $v[&apos;large&apos;], $v[&apos;in&apos;], $v[&apos;small&apos;] ); //加载数据 从第三行开始加入 foreach ($cellKey as $key =&gt; $value) &#123; $number = $k+3; $objPHPExcel-&gt;setActiveSheetIndex(0)-&gt;setCellValue($cellKey[$key].$number, $data[$k+2][$key]);//设置表头数据 &#125; &#125; //下载文件 header(&apos;pragma:public&apos;); header(&apos;Content-type:application/vnd.ms-excel;charset=utf-8;name=&quot;&apos;.$xlsTitle.&apos;.xls&quot;&apos;); header(&quot;Content-Disposition:attachment;filename=$fileName.xls&quot;);//attachment新窗口打印inline本窗口打印 $objWriter = \PHPExcel_IOFactory::createWriter($objPHPExcel, &apos;Excel5&apos;); $objWriter-&gt;save(&apos;php://output&apos;); exit;&#125; 导出示例图 导入相关]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHPExcel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React脚手架项目搭建]]></title>
    <url>%2Faitao%2F2018%2F11%2F06%2FReact%E8%84%9A%E6%89%8B%E6%9E%B6%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[全局安装脚手架工具1npm install -g create-react-app 创建项目1234create-react-app react-cli下载完成后 cd react-cli npm start 回调函数当点击按钮时发生的点击事件12345678第一种方案可以通过构造方法的bind(this) 绑定 thisconstruct(props) &#123; super(props); this.increateLikes = this.increateLikes.bind(this);&#125;&lt;button onClick=&#123;this.increateLikes&#125; &quot;&gt;点赞&lt;/button&gt;第二种的方案是直接用es6 的方法写&lt;button onClick=&#123;() =&gt;&#123;this.increateLikes()&#125;&#125;&gt;点赞&lt;/button&gt; 更新组件123456increateLikes() &#123; this.setState(&#123; likes: this.state.likes &#125;)&#125; 生命周期时钟更新1234567891011121314151617181920212223242526272829import React from &apos;react&apos;class DigitalClock extends React.Component &#123; constructor(props) &#123; super(props) this.state = &#123; date: new Date() &#125; &#125; componentDidMount() &#123; this.timer = setInterval(()=&gt; &#123; this.setState(&#123; date:new Date &#125;) &#125;,1000) &#125; componentWillUnmount() &#123; clearInterval(this.timer) &#125; render() &#123; return ( &lt;div className=&quot;digital-clock-component jumbotron&quot;&gt; &lt;h1&gt;&#123;this.state.date.toLocaleTimeString()&#125;&lt;/h1&gt; &lt;/div&gt; ) &#125;&#125;export default DigitalClock 表单123456789101112阻止默认事件event.preventDefault()//非受控组件handSubmit(event) &#123; alert(this.textInput.value) event.preventDefault() //阻止默认事件 &#125;&lt;input type=&quot;text&quot; className=&quot;form-control&quot; ref=&#123;(textInput) =&gt;&#123; this.textInput = textInput &#125;&#125; /&gt; 类似双向数据绑定12345678910&lt;form className=&quot;p-5&quot; onSubmit=&#123;this.handSubmit&#125;&gt; &lt;input type=&quot;text&quot; className=&quot;form-control&quot; ref=&#123;(textInput) =&gt;&#123; this.textInput = textInput &#125;&#125; /&gt; &lt;button className=&quot;btn btn-primary&quot;&gt;留言&lt;/button&gt;&lt;/form&gt; handSubmit(event)&#123;this.props.onAddData(this.textInput.value)event.preventDefault()//阻止默认事件&#125; 当点击提交的时候调用 onAddData(event) 函数,然后在主页面绑定函数123456789101112construct(props)&#123;this.state = &#123; comments:[&apos;信息&apos;]&#125;this.onAddData = this.onAddData.bind(this)&#125;addComment(comment) &#123; this.setState(&#123; comments:[...this.state.comments,comment] &#125;)&#125;... es6 函数方法 表示在旧的之后面追加新的值 contextprops 是由上到下的单向传递Context 提供了在组件中共享此类值的方法]]></content>
      <categories>
        <category>前端框架</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React初体验]]></title>
    <url>%2Faitao%2F2018%2F11%2F05%2FReact%E5%88%9D%E4%BD%93%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[React是一个JavaScript库,可以在浏览器运行，也可以在服务器运行,初次使用可以部署到本地测试，也可以直接使用codepen; 安装官方git地址1、拷贝库到本地 1git clone git@github.com:facebook/react.git 当然没有git可以直接下载压缩包解压到本地即可，关于git安装可以看看这篇： 模版React 独有的 JSX 语法，跟 JavaScript 不兼容。凡是使用 JSX 的地方，都要加上 type=”text/babel”1&lt;script type=&quot;text/babel&quot;&gt;&lt;/script&gt; ReactDOM.render()ReactDOM.render 是 React 的最基本方法，用于将模板转为 HTML 语言，并插入指定的 DOM 节点。12345&lt;div id=&quot;demo&quot;&gt;&lt;/div&gt;ReactDOM.render( &lt;h1&gt;你好，陌生人！&lt;/h1&gt; document.getElementById(&apos;demo&apos;);); JSX 语法允许 HTML 与 JavaScript 的混写遇到 HTML 标签（以 &lt; 开头），就用 HTML 规则解析；遇到代码块（以 { 开头），就用 JavaScript 规则解析。 12345678910111213141516171819202122232425262728293031&lt;div id=&quot;root&quot;&gt;&lt;/div&gt;var arr = [&apos;java&apos;,&apos;php&apos;,&apos;react&apos;];ReactDOM.render( &lt;div&gt; &#123; arr.map(function(value)&#123; return &lt;div&gt;我喜欢&#123;value&#125;&lt;/div&gt; &#125;) &#125; &lt;/div&gt;, //注意这儿有个逗号，每次分段都要有逗号分割 document.getElementById(&apos;root&apos;) //注意这儿没有逗号);当直接使用数组变量时就会将所有的变量顺序展示&lt;div&gt;我喜欢&#123;arr&#125;&lt;/div&gt;--&gt;我喜欢,javaphpreact也可以使用表达式 例如var element = (&lt;div&gt; &#123; arr.map(function(value)&#123; return &lt;div&gt;我喜欢&#123;value&#125;&lt;/div&gt; &#125;) &#125;&lt;/div&gt;);ReactDOM.render( element, document.getElementById(&apos;root&apos;)); 组件React 允许将代码封装成组件（component），然后像插入普通 HTML 标签一样，在网页中插入这个组件。React.createClass 方法就用于生成一个组件类注意，组件类的第一个字母必须大写，否则会报错，比如HelloMessage不能写成helloMessage。另外，组件类只能包含一个顶层标签，否则也会报错. 使用JavaScript函数1234567function Demo(props) &#123; return &lt;h1&gt;你好,&#123;props.name&#125;&lt;/h1&gt;;&#125;ReactDOM.render( &lt;Demo name=&quot;zhang&quot;/&gt;, document.getElementById(&apos;root&apos;)); 使用ES6 class来定义一个组件123456789class Demo extends React.Component &#123; render() &#123; return &lt;h1&gt;Hello, &#123;this.props.name&#125;&lt;/h1&gt;; &#125;&#125;ReactDOM.render( &lt;Demo name=&quot;陌生人！&quot;/&gt;, document.getElementById(&apos;root&apos;)); 写法上有个地方需要注意1234567891011121314151617181920return &lt;h1&gt;Hello, &#123;this.props.name&#125;&lt;/h1&gt;;这个地方可以这样写return &lt;h1&gt; Hello, &#123;this.props.name&#125;&lt;/h1&gt;;但不可以这样写return &lt;h1&gt; Hello, &#123;this.props.name&#125;&lt;/h1&gt;;并且可以这样写return &lt;div&gt; &lt;h1&gt;Hello, &#123;this.props.name&#125;&lt;/h1&gt; &lt;p&gt;你的笑像一条恶犬，撞乱了我的心弦！&lt;/p&gt;&lt;/div&gt;;但不可以这样写return &lt;div&gt; &lt;h1&gt;Hello, &#123;this.props.name&#125;&lt;/h1&gt;&lt;/div&gt;&lt;p&gt;你的笑像一条恶犬，撞乱了我的心弦！&lt;/p&gt;; 组件组合12345678910111213141516171819class Welcome extends React.Component &#123; render() &#123; return &lt;button&gt;Hello, &#123;this.props.name&#125;&lt;/button&gt;; &#125;&#125;class Demo extends React.Component &#123; render() &#123; return &lt;div&gt; &lt;Welcome name=&quot;I&quot; /&gt;, &lt;Welcome name=&quot;Love&quot; /&gt;, &lt;Welcome name=&quot;You&quot; /&gt;, &lt;/div&gt;; &#125;&#125;ReactDOM.render( &lt;Demo /&gt;, document.getElementById(&apos;root&apos;)); 所有的React组件必须像纯函数那样使用它们的props 真实dom节点的获取组件并不是真实的 DOM 节点，而是存在于内存之中的一种数据结构，叫做虚拟 DOM （virtual DOM）。只有当它插入文档以后，才会变成真实的 DOM 。根据 React 的设计，所有的 DOM 变动，都先在虚拟 DOM 上发生，然后再将实际发生变动的部分，反映在真实 DOM上，这种算法叫做 DOM diff ，它可以极大提高网页的性能表现。 但是，有时需要从组件获取真实 DOM 的节点，这时就要用到 ref 属性。123456789101112131415161718var MyComponent = React.createClass(&#123; handleClick: function() &#123; this.refs.myTextInput.focus(); &#125;, render: function() &#123; return ( &lt;div&gt; &lt;input type=&quot;text&quot; ref=&quot;myTextInput&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;Focus the text input&quot; onClick=&#123;this.handleClick&#125; /&gt; &lt;/div&gt; ); &#125;&#125;);ReactDOM.render( &lt;MyComponent /&gt;, document.getElementById(&apos;example&apos;)); stateReact 的一大创新，就是将组件看成是一个状态机，一开始有一个初始状态，然后用户互动，导致状态变化，从而触发重新渲染 UI1234567891011121314151617181920212223var LikeButton = React.createClass(&#123; getInitialState: function() &#123; return &#123;liked: false&#125;; &#125;, //定义初始状态，也就是一个对象，这个对象可以通过 this.state 属性读取。 handleClick: function(event) &#123; this.setState(&#123;liked: !this.state.liked&#125;); &#125;, //当用户点击组件，导致状态变化，this.setState 方法就修改状态值，每次修改以后，自动调用 this.render 方法，再次渲染组件 render: function() &#123; var text = this.state.liked ? &apos;like&apos; : &apos;haven\&apos;t liked&apos;; return ( &lt;p onClick=&#123;this.handleClick&#125;&gt; You &#123;text&#125; this. Click to toggle. &lt;/p&gt; ); &#125;&#125;);ReactDOM.render( &lt;LikeButton /&gt;, document.getElementById(&apos;example&apos;));this.props 表示那些一旦定义，就不再改变的特性，而 this.state 是会随着用户互动而产生变化的特性。 表单用户在表单填入的内容，属于用户跟组件的互动，所以不能用 this.props 读取以下为非受控表单1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768class NameForm extends React.Component &#123; constructor(props)&#123; super(props); this.state = &#123;name: &apos;&apos;,hobby: &apos;&apos;,introduce:&apos;&apos;,book: &apos;&apos;&#125;; this.handleChangeName = this.handleChangeName.bind(this); this.handleChangeHobby = this.handleChangeHobby.bind(this); this.handleChangeIntroduce = this.handleChangeIntroduce.bind(this); this.handleChangeBook = this.handleChangeBook.bind(this); this.handleSubmit = this.handleSubmit.bind(this); &#125; handleChangeName(event) &#123; this.setState(&#123; name:event.target.value &#125;); &#125; handleChangeHobby(event) &#123; this.setState(&#123; hobby:event.target.value &#125;); &#125; handleChangeIntroduce(event) &#123; this.setState(&#123; introduce: event.target.value &#125;) &#125; handleChangeBook(event) &#123; this.setState(&#123; book: event.target.value &#125;) &#125; handleSubmit(event) &#123; console.log(this.state); event.preventDefault(); &#125; render() &#123; return ( &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt; &lt;label&gt; 姓名: &lt;input type=&quot;text&quot; value=&#123;this.state.name&#125; onChange=&#123;this.handleChangeName&#125; /&gt; &lt;/label&gt; &lt;label&gt; 爱好: &lt;input type=&quot;text&quot; value=&#123;this.state.hobby&#125; onChange=&#123;this.handleChangeHobby&#125; /&gt; &lt;/label&gt; &lt;label&gt; 个人简介: &lt;textarea value=&#123;this.state.introduce&#125; onChange=&#123;this.handleChangeIntroduce&#125; &gt;&lt;/textarea&gt; &lt;/label&gt; &lt;label&gt; 喜欢的书 &lt;select value=&#123;this.state.value&#125; onChange=&#123;this.handleChangeBook&#125;&gt; &lt;option value=&quot;1&quot;&gt;Java&lt;/option&gt; &lt;option value=&quot;2&quot;&gt;PHP&lt;/option&gt; &lt;option value=&quot;3&quot;&gt;JavaScript&lt;/option&gt; &lt;option value=&quot;4&quot;&gt;Css&lt;/option&gt; &lt;/select&gt; &lt;/label&gt; &lt;input type=&quot;submit&quot; value=&quot;确定&quot; /&gt; &lt;/form&gt; ) &#125;&#125;ReactDOM.render( &lt;NameForm /&gt;, document.getElementById(&apos;root&apos;)); 非受控组件由于非受控组件将真实数据保存在 DOM 中，因此在使用非受控组件时，更容易同时集成 React 和非 React 代码。如果你想快速而随性，这样做可以减小代码量。否则，你应该使用受控组件。 拉个官网的栗子1234567891011121314151617181920212223class NameForm extends React.Component &#123; constructor(props) &#123; super(props); this.handleSubmit = this.handleSubmit.bind(this); &#125; handleSubmit(event) &#123; alert(&apos;A name was submitted: &apos; + this.input.value); event.preventDefault(); &#125; render() &#123; return ( &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt; &lt;label&gt; Name: &lt;input type=&quot;text&quot; ref=&#123;(input) =&gt; this.input = input&#125; /&gt; &lt;/label&gt; &lt;input type=&quot;submit&quot; value=&quot;Submit&quot; /&gt; &lt;/form&gt; ); &#125;&#125; 组件的生命周期组件的生命周期分成三个状态：123Mounting：已插入真实 DOMUpdating：正在被重新渲染Unmounting：已移出真实 DOM React 为每个状态都提供了两种处理函数，will 函数在进入状态之前调用，did 函数在进入状态之后调用，三种状态共计五种处理函数。 React 还提供两种特殊状态的处理函数。12componentWillReceiveProps(object nextProps)：已加载组件收到新的参数时调用shouldComponentUpdate(object nextProps, object nextState)：组件判断是否重新渲染时调用 123456789101112131415161718192021222324252627282930class Welcome extends React.Component&#123; constructor(props)&#123; super(props); this.state = &#123;opacity: 1.0&#125;; &#125; componentDidMount() &#123; this.timer = setInterval(function () &#123; var opacity = this.state.opacity; opacity -= .05; if (opacity &lt; 0.1) &#123; opacity = 1.0; &#125; this.setState(&#123; opacity: opacity &#125;); &#125;.bind(this), 100); &#125; render() &#123; return ( &lt;div style=&#123;&#123;opacity: this.state.opacity&#125;&#125;&gt; Hello &#123;this.props.name&#125; &lt;/div&gt; ); &#125;&#125;;ReactDOM.render( &lt;Welcome name=&quot;world&quot;/&gt;, document.getElementById(&apos;root&apos;));]]></content>
      <categories>
        <category>前端框架</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[layx初体验]]></title>
    <url>%2Faitao%2F2018%2F11%2F03%2Flayx%E5%88%9D%E4%BD%93%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[Layx 新一代Web弹窗组件，纯原生Javascript实现，不依赖任何第三方框架git 地址： 初次使用第一步：引入 layx.css / layx.min.css 第二步：引入 layx.js / layx.min.js 第三步：打开一个窗口试试layx.html(‘str’,’字符串文本’,’Hello Layx!’); 消息提示1layx.msg('2419 iaitao',&#123;dialogIcon:'success'&#125;);//成功提示 dialogIcon: 提示图标相关如下success：成功图标warn：警告图标error：错误图标help: 帮助图标 窗口皮肤123456789101112layx.msg( '2419 iaitao', &#123; dialogIcon:'success', skin:'cloud' &#125;);//成功提示参数default // 默认有边框cloud // 白色turquoise //青绿色river //蓝色asphalt // 沥青色 提示窗口12layx.alert('操作提示','2419 i aitao！');//提示窗口layx.alert('操作提示','2419 i aitao！',null,&#123;dialogIcon:'success'&#125;);//提示窗口 添加提示图标 打开网页1layx.iframe('localsite','网页打开测试','https://www.baidu.com'); 添加提示方向 ： top 、right、bottom、left1234&lt;a href="#" id="tip-right"&gt;测试&lt;/a&gt;&lt;script type="text/javascript"&gt; layx.tip('只是测试哦.',document.getElementById('tip-right'),'right');&lt;/script&gt; 询问窗口123456789101112131415161718192021222324252627282930layx.confirm('选择','你会选择爱情而放弃事业吗？',function(id)&#123; layx.msg('你的选择是正确的',&#123;dialogIcon:'success'&#125;);//成功提示 layx.destroy(id);&#125;);带图标layx.confirm('选择','你会选择爱情而放弃事业吗？',function(id)&#123; layx.msg('你的选择是正确的',&#123;dialogIcon:'success'&#125;);//成功提示 layx.destroy(id);&#125;,&#123;dialogIcon:'success'&#125;);双向选择layx.confirm('选择','你会选择爱情而放弃事业吗？',null,&#123; buttons:[ &#123; label:'是的', callback:function(id, button, event)&#123; layx.msg('你的选择是正确的,爱情价更高！',&#123;dialogIcon:'success'&#125;);//成功提示 layx.destroy(id); &#125; &#125;, &#123; label:'不会', callback:function(id, button, event)&#123; layx.msg('你的选择是正确的,爱情不能盲目！',&#123;dialogIcon:'success'&#125;);//成功提示 layx.destroy(id); &#125; &#125; ]&#125;,&#123;dialogIcon:'success'&#125;); 加载等待1234567891011layx.load('loadId','数据正在加载中，请稍后');// 5 秒后自动关闭setTimeout(function()&#123; layx.destroy('loadId');&#125;,5000);倒计时窗口layx.iframe('settimeout','打开一个倒计时关闭窗口','https://www.baidu.com',&#123; autodestroy:5000&#125;); 打开窗口和窗口组初始化 窗口宽度：800 高度：600 minWidth：200 minHeight：200，宽度高度支持百分比显示，窗口位置 默认正中间 窗口组12345678910111213141516171819202122232425262728293031layx.group('group',[ &#123; id:'group1', title:'文本窗口', content:'Layx 新一代Web弹窗组件.', bgColor:'#ccc', &#125;, &#123; id:'group2', title:'网页窗口', type:'url', url:'./iframe.html' &#125;, &#123; id:'taobao', title:'百度官网', type:'url', url:'https://www.baidu.com' &#125;],0,&#123; width:600, skin:'cloud', mergeTitle:false, title:'你好呀，我是标题~'&#125;));0 表示默认显示第一个窗口 下标从0开始bgColor 表示页面背景颜色如果需要显示标题就添加下面两个参数，不需要就不用加 mergeTitle:false, title:'你好呀，我是标题~' 遮罩窗口123456789101112131415layx.iframe('shadow','打开一个遮罩、阻隔窗口，点击窗口外试试','http://www.baidu.com',&#123; shadable:true&#125;);shadable 透明度 取值0~1 浮点值 透明度依次递减点击空白地方关闭layx.iframe('shadow-click','点击阻隔空白地方关闭窗口','http://www.baidu.com',&#123; shadable:0.2, control:true, border:false, shadow:false, shadeDestroy:true // 点击空白地方关闭&#125;);control 设置 false 将不显示控制标题栏，同时窗口拖动功能失效，需手动调用关闭方法关闭窗口。border:false 表示无边框 自定义样式123456789101112131415161718layx.iframe('radiu-style','自定义外观，比如圆角','./iframe.html',&#123; style:layx.multiLine(function()&#123;/* icon:false, #layx-radiu-style&#123; border-radius:4px; -webkit-border-radius:4px; -moz-border-radius:4px; -ms-border-radius:4px; &#125; #layx-radiu-style .layx-window-icon&#123; color:#f00; &#125;*/&#125;)&#125;);icon 打开窗口的图标，可以去掉也可以自定义例如：icon:'&lt;img src="http://img.zcool.cn/community/019c2958a2b760a801219c77a9d27f.jpg" style="height:22px;display:block;" /&gt;', 关闭窗口12parent.layx.destroy(id); // 方法一（推荐）top.layx.destroy(id); // 方法二]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Layx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[thinkphp标签循环嵌套]]></title>
    <url>%2Faitao%2F2018%2F11%2F02%2Fthinkphp%E6%A0%87%E7%AD%BE%E5%BE%AA%E7%8E%AF%E5%B5%8C%E5%A5%97%2F</url>
    <content type="text"><![CDATA[thinkphp volist 多重循环嵌套key]]></content>
  </entry>
  <entry>
    <title><![CDATA[Jquery对input的一些操作]]></title>
    <url>%2Faitao%2F2018%2F11%2F02%2FJquery%E5%AF%B9input%E7%9A%84%E4%B8%80%E4%BA%9B%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[场景：对于选中，选择的一些操作，比如：勾选导出，获得全部选中的值等等 获得全部选中的值html 部分代码：1234567&lt;div class="checkbox"&gt; &lt;label&gt; &lt;input type="checkbox" name="ids[]" value="1"&gt; &lt;span class="text"&gt;&lt;/span&gt; &lt;/label&gt; ......&lt;/div&gt; javascript 代码：1234567891011121314function getAllValue()&#123; var ids = new Array(); i = 0; $("input[name^='ids']:checked").each(function()&#123;//找到所有被选中的值 var val = $(this).val(); ids[i] = val; i++; &#125;); var len = ids.length; if(len === 0)&#123; return false; &#125; return ids;&#125; 勾选多项进行操作$.getJSON 简介：JSON（JavaScript Object Notation）即JavaScript对象表示法，是一种轻量级的数据交换格式。它非常便于编程人员对数据的处理，也便于机器对数据的解析和生成，应用非常广泛。json文件可以保存为“test.json”这样的文件，json数据的一般格式如下（“{ }”中的为对象，“[ ]”中的为数组)123456789101112131415function operate()&#123; var url = $(this).attr('url');//获得操作使用的url地址 var ids = getAllValue();//调用上列使用的方法 if(!ids)&#123; return false; &#125; $.getJSON(url,&#123;'t':new Date().getTime()&#125;,function(d)&#123; //发送get请求 返回结构比如：['status'=&gt;1|0,'data'=&gt;[],'msg'=&gt;'ok'] if(d.status&gt;0)&#123; alert(d.msg);//成功信息 &#125;else&#123; alert(d.msg);//失败信息 &#125; &#125;&#125; 反选操作html 示例12345678910111213&lt;div&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt; &lt;label&gt; &lt;input type="checkbox" name="ids[]" value="1"&gt; &lt;span class="text"&gt;&lt;/span&gt; &lt;/label&gt; &lt;/td&gt; &lt;/tr&gt; ...... &lt;/table&gt;&lt;/div&gt; JavaScript 示例1234567891011121314$('.reverse-select').on('click',function()&#123;//反选 class="reverse-select" var is_check = $(this).prop('checked'); $(this).parents('table').find("input[name^='ids']").each(function()&#123; //查找节点遍历 也可使用 $("table input[name^='ids']").each(); var has_check = $(this).prop('checked'); if(is_check &amp;&amp; !has_check)&#123; $(this).prop('checked',true); &#125;else&#123; if(has_check &amp;&amp; !is_check)&#123; $(this).prop('checked',false); &#125; &#125; &#125;&#125;)]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Jquery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP常用字符串总结]]></title>
    <url>%2Faitao%2F2018%2F11%2F02%2FPHP%E5%B8%B8%E7%94%A8%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[PHP 是 “PHP Hypertext Preprocessor” 的首字母缩略词PHP 是一种被广泛使用的开源脚本语言PHP 脚本在服务器上执行PHP 没有成本，可供免费下载和使用 PHP 相关主流框架：thinkphp5.0 看云文档 laravel 中文社区 Phalcon Symfony 排列不分先后。 本文对框架不做讨论 常用字符串函数及使用字符串大小写转换12345$str = 'abc';$low_str = strtolower($str);echo '转换为小写'+$low_str;$uper_str = strtoupper($str);echo '转换为大写'+$uper_str; 替换字符串中的字串mixed substr_replace ( mixed $string , mixed $replacement , mixed $start [, mixed $length ] )substr_replace()在字符串 string 的副本中将由 start 和可选的 length 参数限定的子字符串使用 replacement 进行替换。注： 如果 start 为正数，替换将从 string 的 start 位置开始。 如果 start 为负数，替换将从 string 的倒数第 start 个位置开始。 1234实列：$str = 'abc';$new_str = substr_replace($str,'d',0,$strlen($str));//strlen() 函数计算字符串的长度echo '新的字串的值'+$new_str;//abcd More info: php 文档 字符串与数组之间的相互转化array explode ( string $delimiter , string $string [, int $limit ] )此函数返回由字符串组成的数组，每个元素都是 string 的一个子串，它们被字符串 delimiter 作为边界点分割出来。string implode ( string $glue , array $pieces ) //$glue 默认为空字符串string implode ( array $pieces )implode() 可以接收两种参数顺序，但是 explode() 不行。 12345678910111213实例：$str = 'a,b,c,d';//逗号为分隔字符 相当于 $delimiter ='';$arr = explode(',',$str);dump($arr);得到：array(4) &#123; [0] =&gt; string(1) "a" [1] =&gt; string(1) "b" [2] =&gt; string(1) "c" [3] =&gt; string(1) "d"&#125;$new_str = implode($arr);echo $new_str;//abcd]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP 常用字符串的比较]]></title>
    <url>%2Faitao%2F2018%2F11%2F01%2Fhello-world%2F</url>
    <content type="text"><![CDATA[PHP 是 “PHP Hypertext Preprocessor” 的首字母缩略词PHP 是一种被广泛使用的开源脚本语言PHP 脚本在服务器上执行PHP 没有成本，可供免费下载和使用 PHP 相关主流框架：thinkphp5.0 看云文档 laravel 中文社区 Phalcon Symfony 排列不分先后。 本文对框架不做讨论 常用字符串函数及使用字符串大小写转换12345$str = 'abc';$low_str = strtolower($str);echo '转换为小写'+$low_str;$uper_str = strtoupper($str);echo '转换为大写'+$uper_str; 替换字符串中的字串mixed substr_replace ( mixed $string , mixed $replacement , mixed $start [, mixed $length ] )substr_replace()在字符串 string 的副本中将由 start 和可选的 length 参数限定的子字符串使用 replacement 进行替换。注： 如果 start 为正数，替换将从 string 的 start 位置开始。 如果 start 为负数，替换将从 string 的倒数第 start 个位置开始。 1234实列：$str = 'abc';$new_str = substr_replace($str,'d',0,$strlen($str));//strlen() 函数计算字符串的长度echo '新的字串的值'+$new_str;//abcd More info: php 文档 字符串与数组之间的相互转化array explode ( string $delimiter , string $string [, int $limit ] )此函数返回由字符串组成的数组，每个元素都是 string 的一个子串，它们被字符串 delimiter 作为边界点分割出来。string implode ( string $glue , array $pieces ) //$glue 默认为空字符串string implode ( array $pieces )implode() 可以接收两种参数顺序，但是 explode() 不行。 12345678910111213实例：$str = 'a,b,c,d';//逗号为分隔字符 相当于 $delimiter ='';$arr = explode(',',$str);dump($arr);得到：array(4) &#123; [0] =&gt; string(1) "a" [1] =&gt; string(1) "b" [2] =&gt; string(1) "c" [3] =&gt; string(1) "d"&#125;$new_str = implode($arr);echo $new_str;//abcd]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一篇文章 localStorage 存储]]></title>
    <url>%2Faitao%2F2018%2F11%2F01%2F%E5%AD%98%E5%82%A8%2F</url>
    <content type="text"><![CDATA[多项表单 localStorage 存储适用于多项输入如：radio 、text 、 number12345678910111213141516171819202122232425262728293031323334$(function()&#123; //页面初始加载判断缓存 var lenth = localStorage.length; if(lenth !='' &amp;&amp; lenth !=undefined &amp;&amp; lenth != null) &#123; for(var i= lenth - 1 ; i &gt;0; i--)&#123; var key = localStorage.key(i);//缓存的key var val = localStorage.getItem(key);//缓存的值 var name = key.substring(0,key.length -2);//获得缓存位置的名称 var distinguish = key.substring(key.length -2,key.length); //取的识别字符 if(distinguish === '4a')&#123; $("input[type='radio']").each(function () &#123; if($(this)[0].name === name &amp;&amp; $(this)[0].value === val)&#123; $(this).attr('checked', true); &#125; &#125;); $("input[type='text']").each(function () &#123; if($(this)[0].name === name )&#123; $(this).val(val) &#125; &#125;); &#125; &#125; &#125; &#125;) //监听内容变化 $("input[type='text']").bind("input propertychange",function (event) &#123; localStorage.setItem(event.target.name+'4a', event.target.value); &#125;); $("input[type='radio']").on('input', function(event) &#123; localStorage.setItem(event.target.name+'4a', event.target.value); //设置缓存 名字+识别字符 &#125;);]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Html</tag>
      </tags>
  </entry>
</search>
