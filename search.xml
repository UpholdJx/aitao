<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Vue学习总结]]></title>
    <url>%2Faitao%2F2018%2F11%2F30%2FVue%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[组件DOM元素获取1.$children - 当前组件的子组件2.$el - 当前组件的元素节点3.$parent - 当前组件的父组件4.$root - 获取 new Vue 实例123456789101112131415161718192021222324252627282930313233343536var tempComponent = &#123; template: ` &lt;span&gt;---临时组件---&lt;/span&gt; `&#125;Vue.component(&apos;temp&apos;,tempComponent);var App = &#123; data() &#123; return &#123; isShow:true &#125; &#125;, template:` &lt;div&gt; &lt;temp ref=&quot;temp&quot; /&gt; &lt;input v-if=&quot;isShow&quot; ref=&quot;input&quot; /&gt; &lt;/div&gt; `, mounted() &#123; // console.log(this.$refs.contentComponents.$el); this.$nextTick(function() &#123; this.$refs.input.focus();//使得input获得焦点 &#125;) &#125;&#125;new Vue(&#123; el:&apos;#app&apos;, components: &#123; app: App &#125;, template: ` &lt;div&gt; &lt;app /&gt; &lt;/div&gt; `&#125;)]]></content>
  </entry>
  <entry>
    <title><![CDATA[前端开发总结]]></title>
    <url>%2Faitao%2F2018%2F11%2F28%2F%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[HTMLmap 定位shape 属性用于定义图像映射中对鼠标敏感的区域的形状： shape coords 圆形（circ 或 circle） coords(x,y,z) 多边形（poly 或 polygon） coords=”x1,y1,x2,y2,x3,y3,…” 矩形（rect 或 rectangle） coords=”x1,y1,x2,y2” 12345&lt;img src=&quot;img/2.png&quot; width=900 height=500 usemap=&quot;#map&quot; /&gt;&lt;map name=&quot;map&quot;&gt; &lt;area shap=&quot;rect&quot; coords=&quot;0,0,50,50&quot; href=&quot;&quot; alt=&quot;1&quot;&gt; &lt;area shap=&quot;circle&quot; coords=&quot;400,75,25&quot; href=&quot;&quot; alt=&quot;2&quot;&gt;&lt;/map&gt; 表单1234567891011121314&lt;form action=&quot;&quot; method=&quot;get&quot; accept-charset=&quot;utf-8&quot;&gt; &lt;!-- 分区 --&gt; &lt;fieldset&gt; &lt;legend&gt;--标题或说明性标题--&lt;/legend&gt; &lt;label&gt; &lt;input type=&quot;text/password/submit/hidden/button/etc&quot; name=&quot;&quot; value=&quot;&quot;&gt; 标签 &lt;/label&gt; &lt;label for=&quot;sig&quot;&gt;标签2&lt;/label&gt; &lt;input type=&quot;text&quot; id=&quot;sig&quot;&gt; &lt;button type=&quot;submit&quot;&gt;Submit&lt;/button&gt; &lt;button type=&quot;reset&quot;&gt;Reset&lt;/button&gt; &lt;/fieldset&gt;&lt;/form&gt; CSS1.@规则语法12345678@import &quot;subs.css&quot;;@charset &quot;utf-8&quot;;@media print &#123; /* property: value */&#125;@keyframes fadein &#123; /* property: value */&#125; 2.常用的规则1.@media （用于响应式布局）2.@keyframes （CSS 动画的中间步骤）3.@font-face （引入外部字体） 3.常用伪类 :link IE6+ :visited IE7+:hover IE6中仅可用于链接 :active IE6/7中仅可用于链接:enabled IE9+ :disabled IE9+:checked IE9+ :first-child IE8+:last-child IE9+ :nth-child(even) 可为 odd even 或数字 IE9+:nth-last-child(n) n从 0 开始计算 IE9+ :only-child 仅选择唯一的元素 IE9+:only-of-type IE9+ :first-of-type IE9+:last-of-type IE9+ :nth-of-type(even) IE9+*:nth-last-of-type(2n) IE9+ 4.组合选择 后代选择器 .man h3子选择器 .man&gt;h3兄弟选择器 .man+h3选择器分组 .man,h3 4.文本操作 居中 text-align: start | end | left | right | center | justify | match-parent | start end 垂直对齐 vertical-align: baseline | sub | super | text-top | text-bottom | middle | top | bottom | | 文本缩进 text-indent: | &amp;&amp; [ hanging || each-line ] 文字换行 word-wrap: normal | break-word 文字阴影 text-shadow:none | # 或 text-shadow:none | [{2,3}&amp;&amp;?]# 12345p &#123; text-shadow: 1px 1px 1px #000, 3px 3px 5px blue;&#125;x-y-r color 省略字符 text-overflow: [ clip | ellipsis | ]{1,2} 1234/* 常用配合 */text-overflow: ellipsis;overflow: hidden; /* 溢出截取 */white-space: nowrap; /* 禁止换行 */ 鼠标形状cursor: [[,]* [ auto | crosshair | default | pointer | move | e-resize | ne-resize | nw-resize | n-resize | se-resize | sw-resize | s-resize | w-resize| text | wait | help ]] | inherit 5.盒子模型1.盒子阴影 box-shadow: 4px 6px 3px 0px red;水平-垂直-半径-阴影大小-颜色 特殊字符集详细信息–参考博文图形补充–参考博文]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>CSS</tag>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSV导出数据]]></title>
    <url>%2Faitao%2F2018%2F11%2F27%2FCSV%E5%AF%BC%E5%87%BA%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[导出封装1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/** * @author 2419 * @DateTime 2018-10-09 * @description [使用csv 导出excel] * @param array $head [头部数据] * @param [type] $data [查询数据] * @param array $row_data [展示的行内数据和头部对应] * @param string $filename [文件名称] * @return [type] [下载文件] */public function putCsv(array $head, $data, $row_data =[], $filename = &quot;test.csv&quot;)&#123; set_time_limit(0); ini_set(&apos;default_charset&apos;, &apos;UTF-8&apos;); $dbusername=config(&quot;database.username&quot;); $dbpwd=config(&quot;database.password&quot;); $dbhost=config(&quot;database.hostname&quot;); $dbname=config(&quot;database.database&quot;); $dsn = &quot;mysql:host=$dbhost;dbname=$dbname&quot;; $dbh = new \PDO($dsn, $dbusername, $dbpwd); $dbh-&gt;setAttribute(\PDO::MYSQL_ATTR_USE_BUFFERED_QUERY, false); $sth = $dbh-&gt;prepare($data); $sth-&gt;execute(); $limit = 100000; if (ob_get_level())&#123; ob_end_clean(); &#125; header(&quot;Content-Type: text/csv;charset=utf-8&quot;); header(&quot;Content-Disposition:attachment;filename=&quot;.$filename); header(&quot;Pragma: no-cache&quot;); header(&quot;Expires: 0&quot;); $fp = fopen(&apos;php://output&apos;, &apos;w&apos;); foreach ($head as $i =&gt; $v)&#123; // CSV的Excel支持GBK编码，一定要转换，否则乱码 $head[$i] = iconv(&apos;utf-8&apos;, &apos;gb2312&apos;, $v); &#125; fputcsv($fp, $head); $num = 0; foreach($sth as $v)&#123; $num++; $row=[]; &lt;!-- 可对数据进行处理 --&gt; if(!empty($v[&apos;end_time&apos;])) &#123; $v[&apos;end_time&apos;] = date(&apos;Y-m&apos;,$v[&apos;end_time&apos;]); &#125; foreach ($row_data as $key =&gt; $value) &#123; $row[] = $v[$value]; &#125; //刷新一下输出buffer，防止由于数据过多造成问题 if ($num%$limit==0) &#123; ob_flush(); flush(); $num = 0; &#125; foreach ($row as $key =&gt; $val) &#123; if (!empty($val)) &#123; $val=is_numeric($val) ? $val . &quot;\t&quot; : $val; $row[$key] = iconv(&apos;utf-8&apos;, &apos;gbk//IGNORE&apos;, $val); &#125; &#125; fputcsv($fp, $row); &#125; fclose($fp); die;&#125; 调用123456789$find = $model-&gt;db()-&gt;where($where)-&gt;alias(&apos;m&apos;);$head = [ &apos;姓名&apos;,&apos;身份证号&apos;,&apos;所属地区&apos;,&apos;添加时间&apos;];//头部信息$data = $find-&gt;fetchSql(true)-&gt;select();$row_data = [&apos;name&apos;,&apos;id_card&apos;,&apos;area_name&apos;,&apos;add_time&apos;];//需要打印的数据信息$filename = &apos;export_file_name.csv&apos;;//导出文件名$this-&gt;putCsv($head,$data,$row_data,$filename);]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>THINKPHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP毫秒级时间处理]]></title>
    <url>%2Faitao%2F2018%2F11%2F27%2FPHP%E6%AF%AB%E7%A7%92%E7%BA%A7%E6%97%B6%E9%97%B4%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[数据库设计MySQL支持的整数类型的存储和范围| 类型 | 占用存储空间 | 带符号最小值 | 无符号最小值 | 带符号最大值 | 无符号最大值 || ——– | —–: | :—-: || TINYINT | 1 | -128 | 0 | 127 | 255 || SMALLINT | 2 | -32768 | 0 | 32767 | 65535 || MEDIUMINT | 3 | -8388608 | 0 | 8388607 | 16777215 || INT | 4 | -2147483648 | 0 | 2147483647 | 4294967295 || BIGINT | 8 | -2^63 | 0 | 2^63-1 | 2^64-1 |int 类型的最大宽度为 11 位，毫秒级的时间戳超过了11位，datetime 类型也只精确到秒级别可以使用bigint 1234567891011121314151617181920212223242526272829303132333435363738/** * @author 2419 * @DateTime 2018-11-26 * @description [毫秒级时间戳处理 时间--时间戳] * @param [type] $time [description] * @return [type] [description] */ public function get_data_format($time) &#123; list($usec, $sec) = explode(".", $time); $date = strtotime($usec); $return_data = str_pad($date.$sec,13,"0",STR_PAD_RIGHT); //不足13位。右边补0 return $return_data; &#125; /** * @author 2419 * @DateTime 2018-11-26 * @description [毫秒级时间戳处理 时间戳--时间] * @param [type] $time [description] * @return [type] [description] */ public function get_microtime_format($time) &#123; if(strstr($time,'.'))&#123; sprintf("%01.3f",$time); //小数点。不足三位补0 list($usec, $sec) = explode(".",$time); $sec = str_pad($sec,3,"0",STR_PAD_RIGHT); //不足3位。右边补0 &#125;else&#123; $usec = $time; $sec = "000"; &#125; $date = date("Y-m-d H:i:s.x",$usec); return str_replace('x', $sec, $date); &#125; 转化为时间戳 $data1 = $this-&gt;get_data_format('2015-12-09 16:02:04.723');转化为时间$data = $this-&gt;get_microtime_format($data1*0.001); 数据导出csv 导出的时候吞数据2015-12-09 16:02:04.723 这种格式csv导出时成了这个 02:04.7解决方法 给后面追加 \t 记住 \t 一定是双引号包裹 “\t”]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue整合]]></title>
    <url>%2Faitao%2F2018%2F11%2F20%2FVue%E6%95%B4%E5%90%88%2F</url>
    <content type="text"><![CDATA[使用初次使用可以直接使用cdn 节点引入js 脚手架cli 安装2.x 版本 npm install -g vue-cli3.x 版本npm install -g @vue/cli查看安装版本vue –version创建项目vue create vue-app安装完成贴换到安装目录npm run serve 课外题一些前端代码的优化12345678910111213141516171819202122232425function calculateGrade(score) &#123; if(score&gt;=90)&#123; return &apos;A&apos; &#125;else if(score &gt;= 80)&#123; return &apos;B&apos; &#125;else if(score &gt;= 70)&#123; return &apos;C&apos; &#125;else if(score &gt;= 60)&#123; return &apos;D&apos; &#125;else &#123; return &apos;E&apos; &#125;&#125;优化为function calculateGrade(score)&#123; const table = &#123; 100: &apos;A&apos;, 90: &apos;A&apos;, 80: &apos;B&apos;, 70: &apos;C&apos;, 60: &apos;D&apos;, others: &apos;E&apos; &#125; return table[Math.floor(score/10)*10] || table[&apos;others&apos;]&#125; 以上代码转载自方应杭在饥人谷]]></content>
      <categories>
        <category>前端框架</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>VUE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用CSS整合]]></title>
    <url>%2Faitao%2F2018%2F11%2F19%2F%E5%B8%B8%E7%94%A8CSS%E6%95%B4%E5%90%88%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829&lt;!-- 图片描述 --&gt;.img-desc &#123; color: #b9b9b9; text-align: center; font-size: 12px;&#125;&lt;!-- 更好看的分割线样式 --&gt;hr &#123; border: 0; border-bottom: 1px solid #ddd; margin-bottom: 25px; margin-top: 25px; box-shadow: 0 2px 0 rgba(229, 229, 229, 0.4);&#125;&lt;!-- 超链接 --&gt;a &#123; /* 腾讯的产品用户体验最好，腾讯系产品爱用的链接颜色 */ color: #3481cf;&#125;a:hover &#123; color: #00a4ff;&#125;&lt;!-- 文本处理 --&gt;/* 使得更显眼一点 */h1, h2, h3, h4, h5, h6, h7, b, strong &#123; text-shadow: 0 1px white; color: #000;&#125; 阴影处理1box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.08), 0 3px 4px 0 rgba(0, 0, 0, 0.01); flex 布局1.水平排列12345&lt;ul&gt; &lt;li&gt;menu-one&lt;/li&gt; &lt;li&gt;menu-two&lt;/li&gt; &lt;li&gt;menu-three&lt;/li&gt;&lt;/ul&gt; .css 实现1234ul li &#123; float:left; width:33.3%;&#125; .flex 实现123ul &#123; flex:1;&#125;]]></content>
      <categories>
        <category>前端资源模块化</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP函数]]></title>
    <url>%2Faitao%2F2018%2F11%2F19%2FPHP%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[系统函数1.字符串函数strlen：获取字符串长度，字节长度 substr：字符串截取，获取字符串（按照字节进行截取） strchr：与substr相似，从指定位置截取一直到最后 strrchr（获取文件后缀名）：与strchr一样，只是从右边开始查找字符 strtolower：所有的字符都小写（针对英文字母） strtoupper：所有的字符都大写 strrev：字符串反转（只能反转英文：英文存储只有一个字节），按照字节进行反转 strpos：从字符串中找对应字符出现的位置（数字下标），从最左边开始找 strrpos：与strpos一样，只是从字符串的右边开始找 trim：去掉函数两边的字符，默认是空格 2.时间日期函数time：得到当前时间的时间戳（整型：从格林威治时间1970年1月1日0时0分0秒开始）秒数 date：时间序列化函数，将指定的时间戳转换成规定时间日期的显示格式（随意的字符串：有专业的格式符规定），如果没有指定时间戳，系统默认使用当前时间的时间戳 strtotime：时间日期格式的字符串转换成对应的时间戳（只要是正确的英语时间表达方式，都可以进行转换） microtime：微秒时间戳，根据不同的要求返回不同的结果 混合 microtime (布尔类型 )，可以返回一个浮点数的时间，也可以返回一个数组（时间戳和微秒数） 3.数学相关函数abs：绝对值 floor：向下取整 floor(3.2) 结果等于3 ceil：向上取整 round：四舍五入 rand：取得一个指定范围内的随机整数 mt_rand：取得一个指定范围内的随机整数（效率更高） 4.数组相关函数key：获取当前数组当前指针所指向的元素的下标 current：获取的当前指针指向元素的数值 next：获取下一个元素的值，并且将指针下移 prev：获取上一个元素的值，并且将指针上移 end ：将指针移到数组的最后一个元素，并返回最终指针位置的值 reset：将指针移到数组的第一个元素，返回最终指针位置的值 array_keys：获取一个数组的所有键名，返回一个索引数组 array_values：获取一个数组的所有值，返回一个索引数组 explode：爆炸，将一个字符串按照某个指定的规则（通常是特殊字符），将数组分成多个段，每一段都当做一个数组的元素，返回一个索引数组 implode：粘合，将一个数组内部的所有元素按照某个指定的规则（特殊字符），将所有的元素拼接成一个字符串 array_merge：合并，指的是将两个数组中的元素进行累计。如果后面的数组与前面的数组有下标（键名：关联）相同的，那么后面的元素的值会覆盖前面的；如果是索引的相同下标，会自动的修改下标叠加到前面的数组里 5.判断变量is_bool：判断是否是布尔类型 is_float：判断浮点型 is_integer：判断整型 is_object：判断对象 is_array：判断数组 is_string：判断字符串 is_resource：判断资源 is_scalar：scalar是标量的，判断是基本数据类型：整型，浮点型，布尔型和字符串型 is_null：是否为空 is_numeric：判断数字或者纯数字组成的字符串 gettype：获得数据类型 settype：改变数据类型 6.文件操作函数opendir(路径)：打开一个路径资源（将路径内部的所有数据读入到内存） readdir(路径资源)：从文件夹资源中读取当前资源指针所指向的文件的名字，指针会向下移动一位 closedir(资源)：释放对应的文件资源 scandir(路径)：读取一个路径内部的所有文件名，返回一个数组，数组的每一个元素都是文件名。 file_exists：判断一个文件是否存在（文件是广义：路径和文件） is_dir：判断一个指定路径是否存在（文件夹） is_file：判断一个指定路径是否是文件（文件） mkdir：创建一个路径，如果路径存在就会报错 rmdir：移除文件夹 file_get_contents：从一个指定的文件内读取数据内容。 file_put_contents：将指定的字符串写入到对应的文件 fopen：打开一个文件资源 fgetc：c代表character，一次读取一个字符 fgets：s代表string，代表可以读取多个字符，取决于指定的读取长度或者是否碰到换行（最多只能读取一行数据） 两个函数都是对当前资源指针进行操作，读取之后都会将指针下移 fread：获取指定长度的数据直到文件结束 fwrite：向文件资源指针所在的位置写入数据，写东西不会将当前位置已有的东西往后移，而是会覆盖 fseek：将指针指定到对应的位置 fclose：使用对应的文件资源 copy：复制 unlink：删除文件 rename：重命名文件 filemtime：m代表modify，文件最后被修改的时间 filesize：文件大小（字节） fileperms：文件权限（Linux下的八进制） 本文转载自：(https://www.jb51.net/article/104830.htm) 回调函数123456789101112131415161718192021222324252627282930313233function fun1() &#123; echo &quot;is function 1&quot;;&#125;function fun2($fun1) &#123; $fun1();&#125;fun2(&apos;fun1&apos;); // is function 1array_walk() 主要用于对某个数组的迭代，相当于 foreach；array_map() 主要是根据某个/某几个数组产生一个新的数组，常应用于递归效果！$arr = [ &apos;name&apos; =&gt;&apos;张&apos;, &apos;sex&apos;=&gt;&apos;男&apos;, &apos;age&apos;=&gt;&apos;2&apos;];$res = array_map(function($n)&#123; var_dump($n); &lt;!-- string(3) &quot;张&quot; string(3) &quot;男&quot; string(1) &quot;2&quot; --&gt;&#125;, $arr);$res2 = array_walk($arr, function($v,$k)&#123; var_dump($k.&apos;=&gt;&apos;.$v); &lt;!-- string(9) &quot;name=&gt;张&quot; string(8) &quot;sex=&gt;男&quot; string(6) &quot;age=&gt;2&quot; --&gt;&#125;);]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>ThinkPhp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ThinkPhp5知识点]]></title>
    <url>%2Faitao%2F2018%2F11%2F19%2FThinkPhp5%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[异常处理1.异常12345678910抛出异常throw new Exception(&quot;Value must be 1 or below&quot;);抛出捕获异常try &#123; checkNum(10);//创建 checkNum()函数。它检测数字是否大于 1。如果是，则抛出一个异常 echo &apos;If you see this, the number is 1 or below&apos;;&#125; //捕获异常catch (Exception $e) &#123; echo &apos;Message: &apos; . $e-&gt;getMessage();&#125; 2.自定义异常类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117class MyHttpException extends Exception&#123; private $statusCode; /** * HttpException constructor. * @param int $statusCode * @param string $message * @param int $code * @param $exception */ public function __construct($statusCode, $message = &apos;&apos;, $code = 0, $exception = null) &#123; parent::__construct($message, $code, $exception); $this-&gt;statusCode = $statusCode; $this-&gt;getStatusCode(); &#125; public function getStatusCode() &#123; return static::sendHttpStatus($this-&gt;statusCode,$this-&gt;message); &#125; /** * 发送HTTP响应状态码 * @param $code * @param string $error * @param array|null $data * @internal param null $message */ static function sendHttpStatus($code, $error = &apos;&apos;, $data = null) &#123; static $_status = array( // Informational 1xx 100 =&gt; &apos;Continue&apos;, 101 =&gt; &apos;Switching Protocols&apos;, // Success 2xx 200 =&gt; &apos;OK&apos;, 201 =&gt; &apos;Created&apos;, 202 =&gt; &apos;Accepted&apos;, 203 =&gt; &apos;Non-Authoritative Information&apos;, 204 =&gt; &apos;No Content&apos;, 205 =&gt; &apos;Reset Content&apos;, 206 =&gt; &apos;Partial Content&apos;, // Redirection 3xx 300 =&gt; &apos;Multiple Choices&apos;, 301 =&gt; &apos;Moved Permanently&apos;, 302 =&gt; &apos;Found&apos;, // 1.1 303 =&gt; &apos;See Other&apos;, 304 =&gt; &apos;Not Modified&apos;, 305 =&gt; &apos;Use Proxy&apos;, // 306 is deprecated but reserved 307 =&gt; &apos;Temporary Redirect&apos;, // Client Error 4xx 400 =&gt; &apos;Bad Request&apos;, 401 =&gt; &apos;Unauthorized&apos;, 402 =&gt; &apos;Payment Required&apos;, 403 =&gt; &apos;Forbidden&apos;, 404 =&gt; &apos;Not Found&apos;, 405 =&gt; &apos;Method Not Allowed&apos;, 406 =&gt; &apos;Not Acceptable&apos;, 407 =&gt; &apos;Proxy Authentication Required&apos;, 408 =&gt; &apos;Request Timeout&apos;, 409 =&gt; &apos;Conflict&apos;, 410 =&gt; &apos;Gone&apos;, 411 =&gt; &apos;Length Required&apos;, 412 =&gt; &apos;Precondition Failed&apos;, 413 =&gt; &apos;Request Entity Too Large&apos;, 414 =&gt; &apos;Request-URI Too Long&apos;, 415 =&gt; &apos;Unsupported Media Type&apos;, 416 =&gt; &apos;Requested Range Not Satisfiable&apos;, 417 =&gt; &apos;Expectation Failed&apos;, 422 =&gt; &apos;Unprocessable Entity&apos;, // Server Error 5xx 500 =&gt; &apos;Internal Server Error&apos;, 501 =&gt; &apos;Not Implemented&apos;, 502 =&gt; &apos;Bad Gateway&apos;, 503 =&gt; &apos;Service Unavailable&apos;, 504 =&gt; &apos;Gateway Timeout&apos;, 505 =&gt; &apos;HTTP Version Not Supported&apos;, 509 =&gt; &apos;Bandwidth Limit Exceeded&apos; ); if (isset($_status[$code])) &#123; header(&apos;HTTP/1.1 &apos; . $code . &apos; &apos; . $_status[$code]); header(&apos;Content-Type:application/json;charset=utf-8&apos;); if ($code == 200) //2xx状态码 &#123; echo json_encode($data, JSON_UNESCAPED_UNICODE); &#125; else if ($code == 204) &#123; //无响应体 &#125; else &#123; if (empty($error)) &#123; $error = $_status[$code]; &#125; $statusData = [ &apos;code&apos; =&gt;$code, &apos;code_msg&apos; =&gt;$_status[$code], &apos;error_msg&apos; =&gt;$error, ]; echo json_encode($statusData, JSON_UNESCAPED_UNICODE); &#125; &#125; exit(0); &#125;&#125;###返回格式###&#123;&quot;code&quot;: 422,&quot;code_msg&quot;: &quot;Unprocessable Entity&quot;,&quot;error_msg&quot;: &quot;用户名已存在&quot;&#125;### 调用方法 ###在需要的地方直接抛出异常，当然首先需要引入 MyHttpException 类throw new MyHttpException(500, &apos;插入失败&apos;); 验证器使用1、验证器12345678910111213141516171819202122namespace app\common\validate;use think\Validate;class Demo extends Validate&#123; //规则 --多个用 | 分开例如：number|between:1,2 等 protected $rule = [ &apos;name&apos; =&gt; &apos;require&apos;, &apos;tel&apos; =&gt; &apos;require&apos;, ]; //提示信息 protected $message = [ &apos;name.require&apos; =&gt; &apos;请输入姓名&apos;, &apos;tel.require&apos; =&gt; &apos;请输入联系电话&apos;, ];&#125;使用 $validate = validate(&apos;Demo&apos;);if(!$validate-&gt;check($data))&#123; $error_info = $validate-&gt;getError();//错误提示信息--message return $this-&gt;ajaxReturn($error_info,0);&#125;更多验证规则查看类：think\Validate 2、验证场景12345678protected $scene = [ &apos;edit&apos; =&gt; [&apos;name&apos;,&apos;tel&apos;],];$validate = validate(&apos;Demo&apos;);if(!$validate-&gt;scene(&apos;edit&apos;)-&gt;check($data))&#123; $error_info = $validate-&gt;getError();//错误提示信息--message return $this-&gt;ajaxReturn($error_info,0);&#125; 3.表单验证表单中：{:token(‘demo‘)}` 验证器中 //规则 --多个用 | 分开例如：number|between:1,2 等 protected $rule = [ &#39;name&#39; =&gt; &#39;require|token:__demo__&#39;, &#39;tel&#39; =&gt; &#39;require&#39;, ];]]></content>
      <categories>
        <category>PHP框架</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>ThinkPhp5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原生JavaScript操作]]></title>
    <url>%2Faitao%2F2018%2F11%2F16%2F2018-11-16%E5%8E%9F%E7%94%9FJavaScript%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[打开新的窗口 12345678910var open_win = document.getElementById(&apos;open_win&apos;); open_win.addEventListener(&apos;click&apos;,function(e)&#123; openwindow(&apos;https://upholdjx.github.io/aitao/&apos;,200,200); e.preventDefault(); // 避免导航到 &quot;#&quot;&#125;,false);function openwindow(url, height, width) &#123; var t = (window.screen.availHeight - 400) / 2; var l = (window.screen.availWidth - 600) / 2; window.open(url, &quot;Query&quot;, &quot;height=&quot; + height + &quot;, width=&quot; + width + &quot;, top=&quot; + t + &quot;,left=&quot; + l + &quot;,toolbar=no, menubar=no, scrollbars=yes, resizable=no&quot;);&#125; 弹出确认框12345678910var open_win = document.getElementById(&apos;open_win&apos;); open_win.addEventListener(&apos;click&apos;,function(e)&#123; var msg = &apos;你确定要打开此页面？&apos;; if(confirm(msg) === true) &#123;//确定 openwindow(&apos;https://upholdjx.github.io/aitao/&apos;,200,200); &#125;else &#123;//取消 window.location.reload();//刷新当前页面 --- 可选 &#125; e.preventDefault(); // 避免导航到 &quot;#&quot;&#125;,false); 关于页面刷新的几种方式 window.location.reload()window.history.go(0)document.execCommand(‘’Refresh’’) 这三个方法是最快速的。其他的都有明显的浏览器滚动条的出现。 页面自动刷新1.head头部设置1&lt;meta http-equiv=&quot;refresh&quot; content=&quot;20&quot;&gt; 2.js 设置定时器1234function refresh() &#123; window.location.reload();&#125;setTimeout(&apos;myrefresh()&apos;,1000); //指定1秒刷新一次 页面跳转12345678&lt;meta http-equiv=&quot;refresh&quot; content=&quot;5; url=https://upholdjx.github.io&quot; /&gt;&lt;a href=&quot;#main&quot;&gt;跳转&lt;/a&gt;&lt;button onclick=&quot;demoFunction();&quot;&gt;跳转&lt;/button&gt;&lt;a href=&quot;#main&quot; onclick=&quot;return demoFunction();&quot;&gt;跳转&lt;/a&gt;加return的原因是阻止默认事件的跳转如果不加页面在执行demoFunction()函数的同时也发生着href的跳转事件。 数组及对象操作1.遍历对象12345var obj = &#123;name:&apos;zhang&apos;,love:&apos;qiao&apos;,type:&apos;1&apos;&#125;;for(var i in obj) &#123; console.log(i+&apos;---&apos;+obj[i]);&#125;当使用 in 遍历数组的时候对应的是数组的key 删除对象中的某一项12已声明的对象不可删除, 对象中的对象属性可以删除delete obj.type;]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Webpack学习初体验]]></title>
    <url>%2Faitao%2F2018%2F11%2F16%2F2018-11-16Webpack%E5%AD%A6%E4%B9%A0%E5%88%9D%E4%BD%93%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[webpack 用于编译 JavaScript 模块。一旦完成安装，你就可以通过 webpack 的 CLI 或 API 与其配合交互中文文档地址 安装node1.安装node npm 更新1npm install npm@latest -g npm 清除缓存1npm cache clean -f 开始webpack1.安装12npm install -g webpack --全局安装npm install --save-dev webpack --安装到目录 2.npm 5 以上如果在命令行使用需要安装webpackcli1npm install --save-dev webpack-cli 3.资源加载 加载css123456789安装并添加 style-loader 和 css-loader并加载npm install --save-dev style-loader css-loader &#123; test: /\.css$/, use: [ &apos;style-loader&apos;, &apos;css-loader&apos; ]&#125; 加载图片使用 file-loader，我们可以轻松地将这些内容混合到 CSS 中1npm install --save-dev file-loader 4.webpack 配置1234567module.exports = &#123; entry: __dirname './src/index.js', //入口文件 output: &#123; filename: 'bundle.js', path: path.resolve(__dirname, 'dist') &#125;,&#125;]]></content>
      <categories>
        <category>前端资源模块化</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网站收藏]]></title>
    <url>%2Faitao%2F2018%2F11%2F15%2F%E7%BD%91%E7%AB%99%E6%94%B6%E8%97%8F%2F</url>
    <content type="text"><![CDATA[1.教程、学习和网址 前端框架1.material-ui]]></content>
      <categories>
        <category>网站收藏</category>
      </categories>
      <tags>
        <tag>网站收藏</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js判断当前URL的协议(http/https)]]></title>
    <url>%2Faitao%2F2018%2F11%2F15%2Fjs%E5%88%A4%E6%96%AD%E5%BD%93%E5%89%8DURL%E7%9A%84%E5%8D%8F%E8%AE%AE-http-https%2F</url>
    <content type="text"><![CDATA[判断当前URL的协议123var protocol_ = document.location.protocolconsole.log(protocol_);---&gt;返回当前的协议 http:或者 https: 获得当前域名1var domain_ = document.domain; 获取指定字符后面的所有值stringObject.substring(start,stop) start 必需。一个非负的整数，规定要提取的子串的第一个字符在 stringObject 中的位置。stop 可选。一个非负的整数，比要提取的子串的最后一个字符在 stringObject 中的位置多 1。如果省略该参数，那么返回的子串会一直到字符串的结尾。12345678function getCaption(obj,catp)&#123; var index=obj.lastIndexOf(catp); obj=obj.substring(index+1,obj.length); return obj;&#125;测试：var url = &apos;http://www.demo.com?id=1%name=cs&apos;;getCaption(url,&apos;\?&apos;); h5 向指定元素添加事件句柄 element.addEventListener(event, function, useCapture)更多的事件可以参考菜鸟HTML DOM 事件addEventListener() 是 W3C DOM 规范中提供的注册事件监听器的方法1.它允许给一个事件注册多个监听器。 特别是在使用AJAX库，JavaScript模块，或其他需要第三方库/插件的代码。2.它提供了一种更精细的手段控制 listener 的触发阶段。（即可以选择捕获或者冒泡）2.它对任何 DOM 元素都是有效的，而不仅仅只对 HTML 元素有效。更多的addEventListener()规范浏览MDNEventTarget.addEventListener()12345678&lt;!-- html --&gt;&lt;a href="/demo/index.html" id = "demo" class="btn"&gt;&lt;/a&gt;var demo_ = document.getElementById('demo');demo_.addEventListener('click',function(e) &#123; var path_name = e.target.pathname;//得到href 指定的地址 console.log(e.path);//可以查看到事件触发参数 e.preventDefault(); // 避免导航到 "#"&#125;,false)]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用JS集合]]></title>
    <url>%2Faitao%2F2018%2F11%2F14%2F%E5%B8%B8%E7%94%A8JS%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[文章转载地址 检测邮箱是否有效1&lt;input type=&quot;text&quot; name=&quot;email&quot; id=&quot;email&quot;&gt; —-javascript—-12345678910111213141516171819var email = document.getElementById('email');email.addEventListener('change',function(e)&#123; var data = e.target.value; if(ValidateEmail(data)) &#123; alert('有效的邮箱'); &#125;else &#123; alert('无效的邮箱'); &#125; e.preventDefault(); // 避免导航到 "#"&#125;,false);function ValidateEmail(str) &#123; var r = /^[a-zA-Z0-9._%-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]&#123;2,4&#125;$/; if (r.test(str)) &#123; return true; &#125; else &#123; return false; &#125;&#125; 检测手机号是否规范12345678910function ValidateTelPhone(str) &#123; var regu = /^[1][3,4,5,7,8][0-9]&#123;9&#125;$/; var re = new RegExp(regu); if (re.test(str)) &#123; return true; &#125; else &#123; return false; &#125;&#125; 页面跳转表单清空123456function aUrl(url) &#123; window.location.href = url;&#125;//跳转function rForm(formid) &#123; document.getElementById(formid).reset();&#125;//清空 全选 jquery实现12345678910111213141516171819function getSelected()&#123; var ids = new Array(), i=0; $("input[name^='ids']:checked").each(function()&#123; var val = $(this).val(); ids[i] = val; i++; &#125;); if(ids.length == 0)&#123; //选择所有的 i=0; $("input[name^='ids']").each(function()&#123; var val = $(this).val(); ids[i] = val; i++; &#125;); &#125; return ids;&#125; 原生js 12345678function checkAll(id, checkname) &#123; var obj = document.getElementById(id); if (obj.checked) &#123; $("input[name='" + checkname + "']").attr('checked', true) &#125; else &#123; $("input[name='" + checkname + "']").attr('checked', false) &#125;&#125; 窗口打开一个小窗口 12345678910var open_win = document.getElementById(&apos;open_win&apos;); open_win.addEventListener(&apos;click&apos;,function(e)&#123; openwindow(&apos;http://www.guou.njapld.com&apos;,200,200); e.preventDefault(); // 避免导航到 &quot;#&quot;&#125;,false);function openwindow(url, height, width) &#123; var t = (window.screen.availHeight - 400) / 2; var l = (window.screen.availWidth - 600) / 2; window.open(url, &quot;Query&quot;, &quot;height=&quot; + height + &quot;, width=&quot; + width + &quot;, top=&quot; + t + &quot;,left=&quot; + l + &quot;,toolbar=no, menubar=no, scrollbars=yes, resizable=no&quot;);&#125; 数字金额–转汉字金额123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172function atoc(numberValue) &#123; var numberValue = new String(Math.round(numberValue * 100)); // 数字金额 var chineseValue = &quot;&quot;; // 转换后的汉字金额 var String1 = &quot;零壹贰叁肆伍陆柒捌玖&quot;; // 汉字数字 var String2 = &quot;万仟佰拾亿仟佰拾万仟佰拾元角分&quot;; // 对应单位 var len = numberValue.length; // numberValue 的字符串长度 var Ch1; // 数字的汉语读法 var Ch2; // 数字位的汉字读法 var nZero = 0; // 用来计算连续的零值的个数 var String3; // 指定位置的数值 if (len &gt; 15) &#123; alert(&quot;超出计算范围&quot;); return &quot;&quot;; &#125; if (numberValue == 0) &#123; chineseValue = &quot;零元整&quot;; return chineseValue; &#125; String2 = String2.substr(String2.length - len, len); // 取出对应位数的STRING2的值 for (var i = 0; i &lt; len; i++) &#123; String3 = parseInt(numberValue.substr(i, 1), 10); // 取出需转换的某一位的值 if (i != (len - 3) &amp;&amp; i != (len - 7) &amp;&amp; i != (len - 11) &amp;&amp; i != (len - 15)) &#123; if (String3 == 0) &#123; Ch1 = &quot;&quot;; Ch2 = &quot;&quot;; nZero = nZero + 1; &#125; else if (String3 != 0 &amp;&amp; nZero != 0) &#123; Ch1 = &quot;零&quot; + String1.substr(String3, 1); Ch2 = String2.substr(i, 1); nZero = 0; &#125; else &#123; Ch1 = String1.substr(String3, 1); Ch2 = String2.substr(i, 1); nZero = 0; &#125; &#125; else &#123; // 该位是万亿，亿，万，元位等关键位 if (String3 != 0 &amp;&amp; nZero != 0) &#123; Ch1 = &quot;零&quot; + String1.substr(String3, 1); Ch2 = String2.substr(i, 1); nZero = 0; &#125; else if (String3 != 0 &amp;&amp; nZero == 0) &#123; Ch1 = String1.substr(String3, 1); Ch2 = String2.substr(i, 1); nZero = 0; &#125; else if (String3 == 0 &amp;&amp; nZero &gt;= 3) &#123; Ch1 = &quot;&quot;; Ch2 = &quot;&quot;; nZero = nZero + 1; &#125; else &#123; Ch1 = &quot;&quot;; Ch2 = String2.substr(i, 1); nZero = nZero + 1; &#125; if (i == (len - 11) || i == (len - 3)) &#123; // 如果该位是亿位或元位，则必须写上 Ch2 = String2.substr(i, 1); &#125; &#125; chineseValue = chineseValue + Ch1 + Ch2; &#125; if (String3 == 0) &#123; // 最后一位（分）为0时，加上“整” chineseValue = chineseValue + &quot;整&quot;; &#125; return chineseValue;&#125;console.log(atoc(110));|：壹佰壹拾元整]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JQuery插件--backstretch]]></title>
    <url>%2Faitao%2F2018%2F11%2F14%2FJQuery%E6%8F%92%E4%BB%B6-backstretch%2F</url>
    <content type="text"><![CDATA[Backstretch是一个jQuery插件，允许您将动态调整大小的背景图像添加到任何页面。图像将拉伸以适合页面，并随着窗口大小的变化自动调整大小。 下载地址： 建立在网页中包含jQuery库和Backstretch插件文件（最好在页面底部，在结束BODY标记之前）12&lt;script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.js"&gt;&lt;/script&gt;&lt;script src="https://cdn.bootcss.com/jquery-backstretch/2.0.4/jquery.backstretch.min.js"&gt;&lt;/script&gt; 在页面上定义一个区域如：1&lt;div class="container"&gt;&lt;/div&gt; 123456789$(function()&#123; $(&quot;.container&quot;).css(&#123; opacity:0.6 &#125;);//设置透明度 $.backstretch([ &quot;a.jpg&quot;, &quot;b.jpg&quot;, ], &#123; duration: 3000, fade: 750 &#125;);&#125;); 图片切换的间隔时间duration 当给body设置的时候不用指定区域1234$.backstretch([ &quot;a.jpg&quot;, &quot;b.jpg&quot;, ], &#123; duration: 3000, fade: 750 &#125;);]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML5_File_Api]]></title>
    <url>%2Faitao%2F2018%2F11%2F14%2FHTML5-File-Api%2F</url>
    <content type="text"><![CDATA[该规范提供了一种API，用于表示Web应用程序中的文件对象，以及以编程方式选择它们并访问它们的数据。这包括：一个FileList接口，表示来自底层系统的单独选择的文件的数组。当输入元素File Upload处于[HTML]状态时调用用于选择的用户界面。一个Blob接口，表示不可变的原始二进制数据，并允许Blob作为单独的对象访问对象内的字节范围Blob。一个File接口，包括有关文件的只读信息属性，例如其名称和文件的最后修改日期（在磁盘上）。甲FileReader接口，它提供的方法来读取一个File或一个Blob，和一个事件模型获得的结果的这些读取。用于二进制数据（如文件）的URL方案，以便可以在Web应用程序中引用它们。此外，该规范定义了在线程Web应用程序中用于同步读取文件的对象。更多请看FileAPI本文参考博客：HTML5 File API — 让前端操作文件变的可能–韩子迟（网名） FileList接口所有type属性(attribute)为file的 input 元素都有一个files属性(property),用来存储用户所选择的文件1&lt;input type="file" &gt; 123document.querySelector('input').onchange = function() &#123; console.log(this.files[0]);&#125; 如果你想让用户选择多个文件，只需在input元素上使用multiple属性：1&lt;input type="file" id="input" multiple onchange="handleFiles(this.files)"&gt; FileReaderFileReader 对象采用异步方式读取文件，可以为一系列事件指定回调函数。.onabort 方法：读取中断或调用 reader.abort() 方法时触发。.onerror 方法：读取出错时触发。.onload 方法：读取成功后触发。.onloadend 方法：读取完成后触发，不管是否成功。触发顺序排在 onload 或 onerror 后面。.onloadstart 方法：读取将要开始时触发。.onprogress 方法：读取过程中周期性触发。（可以用来获取文件读取的进度） 获取图片的base64编码 12&lt;input type='file' multiple id="fileItem" /&gt;&lt;textarea&gt;&lt;/textarea&gt; 12345678910111213141516171819202122document.querySelector('input').onchange = function() &#123; var reader = new FileReader(); reader.onload = function() &#123; var dataURL = reader.result; &#125;; reader.readAsDataURL(this.files[0]);&#125;;var ipt = document.querySelector('textarea');ipt.ondragover = function () &#123; return false; &#125;;// Add drop handleript.ondrop = function(e) &#123; e.stopPropagation(); e.preventDefault(); e = e || window.event; var files = e.dataTransfer.files; var reader = new FileReader(); reader.onload = function() &#123; var dataURL = reader.result; document.querySelector('textarea').innerHTML = dataURL; &#125;; reader.readAsDataURL(files[0]);&#125;; 上传图片预览功能1234document.querySelector('input').onchange = function() &#123; var files = this.files; document.querySelector("img").src = window.URL.createObjectURL(files[0]);&#125;; 触发隐藏的inpt12&lt;input type="file" id="fileElem" multiple accept="image/*" style="display:none" onchange="handleFiles(this.files)"&gt;&lt;a href="#" id="fileSelect"&gt;Select some files&lt;/a&gt; 123456789101112var fileSelect = document.getElementById("fileSelect"), fileElem = document.getElementById("fileElem");fileSelect.addEventListener("click", function (e) &#123; if (fileElem) &#123; fileElem.click(); &#125; e.preventDefault(); // 避免导航到 "#"&#125;, false);function handleFiles(argument) &#123; console.log(argument);&#125; js 页面打印 所需要打印的代码，用和 1234567891011121314151617function preview(oper)&#123; if (oper &lt; 10)&#123; bdhtml=window.document.body.innerHTML;//获取当前页的html代码 sprnstr=&quot;&lt;!--startprint&quot;+oper+&quot;--&gt;&quot;;//设置打印开始区域 eprnstr=&quot;&lt;!--endprint&quot;+oper+&quot;--&gt;&quot;;//设置打印结束区域 prnhtml=bdhtml.substring(bdhtml.indexOf(sprnstr)+18); //从开始代码向后取html prnhtml=prnhtml.substring(0,prnhtml.indexOf(eprnstr));//从结束代码向前取html window.document.body.innerHTML=prnhtml; window.print(); window.document.body.innerHTML=bdhtml; &#125; else &#123; window.print(); &#125;&#125;&lt;input type=button class=&quot;btn btn-sky shiny btn-sm&quot; title=&apos;打印1&apos; onclick=preview(1) value=打印1&gt;]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[html5全屏浏览]]></title>
    <url>%2Faitao%2F2018%2F11%2F13%2Fhtml5%E5%85%A8%E5%B1%8F%E6%B5%8F%E8%A7%88%2F</url>
    <content type="text"><![CDATA[不多解释h5的特性12&lt;div onclick=&quot;enterFullScreen();&quot; id=&quot;entry_screen&quot;&gt;全屏显示&lt;/div&gt;&lt;div onclick=&quot;enterFullScreen();&quot; id=&quot;exit_screen&quot;&gt;退出全屏显示&lt;/div&gt; 1234567891011121314151617181920212223242526//进入全屏function enterFullScreen() &#123; var de = document.documentElement; if (de.requestFullscreen) &#123; de.requestFullscreen(); &#125; else if (de.mozRequestFullScreen) &#123; de.mozRequestFullScreen(); &#125; else if (de.webkitRequestFullScreen) &#123; de.webkitRequestFullScreen(); &#125; $(&quot;#exit_screen&quot;)[0].style.display = &apos;block&apos;; $(&quot;#entry_screen&quot;)[0].style.display = &apos;none&apos;;&#125;//退出全屏function exitFullScreen() &#123; var de = document; if (de.exitFullscreen) &#123; de.exitFullscreen(); &#125; else if (de.mozCancelFullScreen) &#123; de.mozCancelFullScreen(); &#125; else if (de.webkitCancelFullScreen) &#123; de.webkitCancelFullScreen(); &#125; $(&quot;#exit_screen&quot;)[0].style.display = &apos;none&apos;; $(&quot;#entry_screen&quot;)[0].style.display = &apos;block&apos;;&#125; https://www.cnblogs.com/zichi/p/html5-file-api.html]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Echarts等图表学习]]></title>
    <url>%2Faitao%2F2018%2F11%2F10%2FEcharts%E7%AD%89%E5%9B%BE%E8%A1%A8%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[ECharts，一个使用 JavaScript 实现的开源可视化库，可以流畅的运行在 PC 和移动设备上，兼容当前绝大部分浏览器（IE8/9/10/11，Chrome，Firefox，Safari等），底层依赖轻量级的矢量图形库 ZRender，提供直观，交互丰富，可高度个性化定制的数据可视化图表。github地址 关于样式看官网简单的一个饼图为例，使用图标数据可点击,引入的库如下，需要注意的是jquery 必须在layer之前引入！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;div id="main" style="width: 600px;height:400px;"&gt;&lt;/div&gt;var myChart = echarts.init(document.getElementById('main'));option = &#123; title : &#123; text: '编程语言榜', subtext: '2018年11月', x:'center' &#125;, tooltip : &#123; trigger: 'item', formatter: "&#123;a&#125; &lt;br/&gt;&#123;b&#125; : &#123;c&#125; (&#123;d&#125;%)" &#125;, legend: &#123; orient: 'vertical', left: 'left', data: ['JAVA','C','PYTHON','PHP','JAVASCRIPT'] &#125;, series : [ &#123; name: '访问来源', type: 'pie', radius : '55%', center: ['50%', '60%'], data:[ &#123;value:335, name:'C'&#125;, &#123;value:310, name:'PYTHON'&#125;, &#123;value:234, name:'PHP'&#125;, &#123;value:135, name:'JAVASCRIPT'&#125;, &#123;value:1548, name:'JAVA'&#125; ], itemStyle: &#123; emphasis: &#123; shadowBlur: 10, shadowOffsetX: 0, shadowColor: 'rgba(0, 0, 0, 0.5)' &#125; &#125; &#125; ]&#125;;myChart.setOption(option);if (myChart &amp;&amp; typeof option === "object") &#123; myChart.on('click',function (argument) &#123; var url = 'register.html?param='+argument.name;//点击的值如：JAVA layer.open(&#123; type:2, shadeClose:true, anim:3, maxmin:true, area:['80%','85%'], content:[url,'no'] &#125;) &#125;)&#125; 异步数据加载首先设置加载等待样式，当数据加载完成之后隐藏等待样式12345678910111213141516171819202122默认的为default: &#123; text: &apos;loading&apos;,//加载字体 color: &apos;#c23531&apos;,//加载颜色 textColor: &apos;#000&apos;,//加载字体颜色 maskColor: &apos;rgba(255, 255, 255, 0.8)&apos;,//加载背景遮罩层 zlevel: 0&#125;简单的隐藏样式var showLoading = &#123; maskColor : &apos;rgba(255, 255, 255, 0.8)&apos;, &apos;text&apos;:&apos;数据加载中...&apos;, color:&apos;#FFA537&apos;, textColor:&apos;#000&apos;&#125;;myChart.showLoading();$.post(&quot;url&quot;,function(d)&#123; myChart.hideLoading(); option = &#123;&#125;;//将post 返回的值放进去 myChart.setOption(option);&#125; highcharts 使用体验下载js或者引入库官网地址 还是先来个官网的简单例子123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;div id=&quot;container&quot; style=&quot;max-width:800px;height:400px&quot;&gt;&lt;/div&gt;options = &#123; title: &#123; text: &apos;基本折线图&apos; &#125;, subtitle: &#123; text: &apos;数据来源：hcharts 图表&apos; &#125;, yAxis: &#123; title: &#123; text: &apos;关注人数&apos; &#125; &#125;, legend: &#123; layout: &apos;vertical&apos;, align: &apos;right&apos;, verticalAlign: &apos;middle&apos; &#125;, plotOptions: &#123; series: &#123; label: &#123; connectorAllowed: false &#125;, pointStart: 2011 &#125; &#125;, series: data,//数据 responsive: &#123; rules: [ &#123; condition: &#123; maxWidth: 500 &#125;, chartOptions: &#123; legend: &#123; layout: &apos;horizontal&apos;, align: &apos;center&apos;, verticalAlign: &apos;bottom&apos; &#125; &#125; &#125; ] &#125; &#125;; var chart = Highcharts.chart(&apos;container&apos;,options); 和echarts 差不多，也有加载等待异步加载 chart.showLoading(&apos;正在加载中...&apos;);//加载中 chart.hideLoading();//隐藏]]></content>
      <categories>
        <category>Echarts</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>Echarts</tag>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PDO使用]]></title>
    <url>%2Faitao%2F2018%2F11%2F09%2FPDO%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[PDO(php data object) 数据库访问抽象层,PDO可以访问12种不同的数据库 开启PDO步骤:找到php.ini 、开启:pod_myql_dll扩展 、重启apache 、验证是否登录成功 PDO 主要类别 PDO类:主要用户数据库连接,发送sql语句PDOStatement类:主要用来解释结果集,实现预处理,事物处理PDOException类:主要用于捕获PDO异常 开始连接123456789$dns = 'mysql:dbname=demo;host=localhost;port=3306'; //数据源名称 本文使用MySQL$username = 'root';//数据库账号$password = 'root';//数据库密码try &#123; $pdo = new PDO($dns, $username, $password);&#125;catch(PDOException $e) &#123; die('数据库连接失败：&lt;br/&gt;' . $e);&#125;$pdo-&gt;setAttribute(PDO::ATTR_EMULATE_PREPARES,false);//选择连接失败的时候处理异常 查询–execute例如:检测用户登录 –校验用户名密码是否匹配，密码使用MD5加密。 query用来处理有结果集的，如select， 返回 PDOStatement 对象，失败返回false（当为 PDO::ERRMODE_SILENT，这也是默认的值）exec用来处理有返回影响行数的（int），如 insert（插入的行数）、 delete（删除的行数） 、update（和原数值不等才算）， 失败返回false （当为 PDO::ERRMODE_SILENT，这也是默认的值）prepare 执行所有sql，可以完全替代 query,exec的功能 12345678910$sql ='SELECT * FROM `user` WHERE `name`=:username AND `password`=:password';$stmt = $pdo-&gt;prepare($sql);$password = $md5($password);$stmt -&gt;bindParam(':username',$username);//绑定参数$stmt -&gt;bindParam(':password',$password);$stmt-&gt;execute();$user = $stmt-&gt;fetch(PDO::FETCH_ASSOC);if(empty($user)) &#123; throw new MyHttpException(500, '用户名或密码错误');//抛出异常&#125; pdo中有两种占位符号 1、? 参数 — 索引数组， 按索引顺序使用 2、名子参数 —-关联数组， 按名称使用，和顺序无关当使用占位符的时候需要绑定参数，如果使用?的适合数组下标必须从0开始，例子如下:123456789101112131415$sql = &apos;INSERT INTO `user` VALUES(null,?,?)&apos;;$stmt = $pdo-&gt;prepare($sql);$data = [ 0=&gt;&apos;username&apos;, 1=&gt;&apos;password&apos;,];$pdo-&gt;beginTransaction(); //开启事物$stmt-&gt;execute($data);$result[&apos;user_id&apos;] = $pdo-&gt;lastInsertId(); //最后插入的id,有多条时返回的是第一条的idif(!empty($result[&apos;user_id&apos;])) &#123; $pdo-&gt;commit();//插入成功，提交事物&#125;else &#123; $pdo-&gt;rollBack(); //插入失败，回滚事物 throw new MyHttpException(500, &apos;插入失败&apos;);//抛出异常&#125; 查询单条记录的时候可以使用 fetch(PDO::FETCH_ASSOC);当查询有多条记录的时候使用 fetchAll(PDO::FETCH_ASSOC); 12345678910111213141516171819202122232425栗子：查询文章详情 --- 单条$sql = 'SELECT * FROM `article` WHERE `id` =:articleId';$stmt = $pdo-&gt;prepare($sql);$createTime = time();$stmt -&gt;bindParam(':articleId',$articleId);$stmt-&gt;execute();$article = $stmt-&gt;fetch(PDO::FETCH_ASSOC);查询多条文章 --- 可以加入分页控制传入的参数 如： $userId,$page=1,$limit=10$sql = 'SELECT * FROM `article` WHERE `user_id`=:userId ORDER BY `id` DESC LIMIT :offset,:limit';$offset = ($page - 1) * $limit;if ($offset &lt; 0)&#123; $offset = 0;&#125;$stmt = $pdo-&gt;prepare($sql);$stmt-&gt;bindParam(':userId', $userId, PDO::PARAM_INT);$stmt-&gt;bindParam(':offset', $offset, PDO::PARAM_INT);$stmt-&gt;bindParam(':limit', $limit, PDO::PARAM_INT);$stmt-&gt;execute();$data = $stmt-&gt;fetchAll(PDO::FETCH_ASSOC); 关于访问其他数据库自行折腾，下面是访问Oracle的感兴趣的可以去看看。php如何利用PDO访问oracle数据库的方法详解本文参考文章思齐博客–PDO 用法学习PHP中文网–PHP之详解PDO]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PDO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHPExcell导入导出相关学习]]></title>
    <url>%2Faitao%2F2018%2F11%2F07%2FPHPExcell%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA%E7%9B%B8%E5%85%B3%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[本项目github 上官方已经放弃维护，官方推荐：PhpSpreadsheet 具体自行尝试。 初始化引入文件123456扩展安装composer require phpoffice/phpexceluse PHPExcel;use PHPExcel_Style_Alignment;//如果需要定义样式需要引入此文件使用$objPHPExcel = new PHPExcel(); 合并拆分单元格12$objPHPExcel-&gt;getActiveSheet()-&gt;mergeCells('A1:A2');//合并单元格$objPHPExcel-&gt;getActiveSheet()-&gt;unmergeCells( 'A28:B28');// A28:B28再拆分 获得合并后的单元格12$mergeInfo = $objPHPExcel-&gt;getActiveSheet()-&gt;getMergeCells();//获得合并后的单元格 格式例如：A1:B1 ... 样式设置1234567891011字体加粗、居中、$objPHPExcel-&gt;getActiveSheet()-&gt;getStyle('A1:X2')-&gt;applyFromArray( array( 'font' =&gt; array ( 'bold' =&gt; true ), 'alignment' =&gt; array ( 'horizontal' =&gt; PHPExcel_Style_Alignment::HORIZONTAL_RIGHT , ), )); 填充背景色123//设置填充的样式和背景色$objPHPExcel-&gt;getActiveSheet()-&gt;getStyle( &apos;A1:E1&apos;)-&gt;getFill()-&gt;setFillType(PHPExcel_Style_Fill::FILL_SOLID);$objPHPExcel-&gt;getActiveSheet()-&gt;getStyle( &apos;A1:E1&apos;)-&gt;getFill()-&gt;getStartColor()-&gt;setARGB(&apos;FF808080&apos;); 设置列的宽度 12$objActSheet-&gt;getColumnDimension( &apos;B&apos;)-&gt;setAutoSize(true); //内容自适应$objActSheet-&gt;getColumnDimension( &apos;A&apos;)-&gt;setWidth(30); //30宽 下载文件123456789$xlsTitle = iconv(&apos;utf-8&apos;, &apos;gb2312&apos;, &apos;下载文件&apos;);//文件名称$fileName = $title.date(&apos;_YmdHis&apos;);//文件名称header(&apos;pragma:public&apos;);header(&apos;Content-type:application/vnd.ms-excel;charset=utf-8;name=&quot;&apos;.$xlsTitle.&apos;.xls&quot;&apos;);header(&quot;Content-Disposition:attachment;filename=$fileName.xls&quot;);//attachment新窗口打印inline本窗口打印$objWriter = \PHPExcel_IOFactory::createWriter($objPHPExcel, &apos;Excel5&apos;);$objWriter-&gt;save(&apos;php://output&apos;);exit; 导出实例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public function exportExcel($title,$list)&#123;$objPHPExcel = new PHPExcel();$xlsTitle = iconv(&apos;utf-8&apos;, &apos;gb2312&apos;, $title);//文件名称 $fileName = $title.date(&apos;_YmdHis&apos;);//文件名称 $topNumber = 1;//第一行表头 $topNumber2 = 2;//第二行表头 $cellKey = [&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;D&apos;,&apos;E&apos;]; //处理表头标题 $objPHPExcel-&gt;getActiveSheet()-&gt;mergeCells(&apos;A1:A2&apos;); $objPHPExcel-&gt;getActiveSheet()-&gt;mergeCells(&apos;B1:B2&apos;); $data[0] = array(&apos;名称&apos;, &apos;变量&apos;,&apos;数字&apos;); $data[1] = array(&apos;&apos;,&apos;&apos;,&apos;大&apos;, &apos;中&apos;,&apos;小&apos;);$objPHPExcel-&gt;getActiveSheet()-&gt;mergeCells(&apos;C1:E1&apos;); $objPHPExcel-&gt;getActiveSheet()-&gt;getStyle(&apos;A1:E2&apos;)-&gt;applyFromArray( array( &apos;font&apos; =&gt; array ( &apos;bold&apos; =&gt; true ), &apos;alignment&apos; =&gt; array ( &apos;horizontal&apos; =&gt; PHPExcel_Style_Alignment::HORIZONTAL_RIGHT , ), ));//设置表头加粗 foreach ($cellKey as $key =&gt; $value) &#123; $objPHPExcel-&gt;setActiveSheetIndex(0)-&gt;setCellValue($cellKey[$key].$topNumber2, $data[1][$key]);//设置表头数据 &#125; $mergeInfo = $objPHPExcel-&gt;getActiveSheet()-&gt;getMergeCells();//获得合并后的单元格 $new_arr = []; foreach ($mergeInfo as $key =&gt; $value) &#123; $new_arr[] = substr($value,0,2);//分割合并后的单元格 获得单列 &#125; foreach ($new_arr as $key =&gt; $value) &#123; $objPHPExcel-&gt;setActiveSheetIndex(0)-&gt;setCellValue($value, $data[0][$key]);//设置表头数据 &#125; //导出数据模拟 $data_list[0] = [ &apos;name&apos;=&gt;&apos;hhh&apos;, &apos;variable&apos;=&gt;&apos;卫星人&apos;, &apos;large&apos;=&gt;12, &apos;in&apos;=&gt;20, &apos;small&apos;=&gt;222 ]; foreach($data_list as $k=&gt;$v) &#123; $data[$k + 2] = array( $v[&apos;name&apos;], $v[&apos;variable&apos;], $v[&apos;large&apos;], $v[&apos;in&apos;], $v[&apos;small&apos;] ); //加载数据 从第三行开始加入 foreach ($cellKey as $key =&gt; $value) &#123; $number = $k+3; $objPHPExcel-&gt;setActiveSheetIndex(0)-&gt;setCellValue($cellKey[$key].$number, $data[$k+2][$key]);//设置表头数据 &#125; &#125; //下载文件 header(&apos;pragma:public&apos;); header(&apos;Content-type:application/vnd.ms-excel;charset=utf-8;name=&quot;&apos;.$xlsTitle.&apos;.xls&quot;&apos;); header(&quot;Content-Disposition:attachment;filename=$fileName.xls&quot;);//attachment新窗口打印inline本窗口打印 $objWriter = \PHPExcel_IOFactory::createWriter($objPHPExcel, &apos;Excel5&apos;); $objWriter-&gt;save(&apos;php://output&apos;); exit;&#125; CSV 导出12345678910111213141516171819202122232425262728293031323334353637public function put_csv($list,$title,$filename = &quot;CSV&quot;)&#123; $file_name=$filename.date(&quot;mdHis&quot;,time()).&quot;.csv&quot;; header ( &apos;Content-Type: application/vnd.ms-excel&apos; ); header ( &apos;Content-Disposition: attachment;filename=&apos;.$file_name ); header ( &apos;Cache-Control: max-age=0&apos; ); $file = fopen(&apos;php://output&apos;,&quot;a&quot;); $limit=1000; $calc=0; foreach ($title as $v)&#123; $tit[]=iconv(&apos;UTF-8&apos;, &apos;GB2312//IGNORE&apos;,$v); &#125; fputcsv($file,$tit); foreach ($list as $v)&#123; $calc++; if($limit==$calc)&#123; ob_flush(); flush(); $calc=0; &#125; foreach ($v as $t)&#123; if(!empty($t))&#123; $t = is_numeric($t) ? $t.&quot;\t&quot;:$t; &#125; $tarr[]=iconv(&apos;UTF-8&apos;, &apos;GB2312//IGNORE&apos;,$t); &#125; fputcsv($file,$tarr); unset($tarr); &#125; unset($list); fclose($file); exit();&#125;调用方法$info = Message::order(&apos;id desc&apos;)-&gt;select()-&gt;toArray();$header = [&apos;mes1&apos;,&apos;mes2&apos;];$filename = &apos;导出数据&apos;;$this-&gt;put_csv($info,$header,$filename);]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHPExcel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React脚手架项目搭建]]></title>
    <url>%2Faitao%2F2018%2F11%2F06%2FReact%E8%84%9A%E6%89%8B%E6%9E%B6%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[全局安装脚手架工具1npm install -g create-react-app 创建项目1234create-react-app react-cli下载完成后 cd react-cli npm start 回调函数当点击按钮时发生的点击事件12345678第一种方案可以通过构造方法的bind(this) 绑定 thisconstruct(props) &#123; super(props); this.increateLikes = this.increateLikes.bind(this);&#125;&lt;button onClick=&#123;this.increateLikes&#125; &quot;&gt;点赞&lt;/button&gt;第二种的方案是直接用es6 的方法写&lt;button onClick=&#123;() =&gt;&#123;this.increateLikes()&#125;&#125;&gt;点赞&lt;/button&gt; 更新组件123456increateLikes() &#123; this.setState(&#123; likes: this.state.likes &#125;)&#125; 生命周期时钟更新1234567891011121314151617181920212223242526272829import React from &apos;react&apos;class DigitalClock extends React.Component &#123; constructor(props) &#123; super(props) this.state = &#123; date: new Date() &#125; &#125; componentDidMount() &#123; this.timer = setInterval(()=&gt; &#123; this.setState(&#123; date:new Date &#125;) &#125;,1000) &#125; componentWillUnmount() &#123; clearInterval(this.timer) &#125; render() &#123; return ( &lt;div className=&quot;digital-clock-component jumbotron&quot;&gt; &lt;h1&gt;&#123;this.state.date.toLocaleTimeString()&#125;&lt;/h1&gt; &lt;/div&gt; ) &#125;&#125;export default DigitalClock 表单123456789101112阻止默认事件event.preventDefault()//非受控组件handSubmit(event) &#123; alert(this.textInput.value) event.preventDefault() //阻止默认事件 &#125;&lt;input type=&quot;text&quot; className=&quot;form-control&quot; ref=&#123;(textInput) =&gt;&#123; this.textInput = textInput &#125;&#125; /&gt; 类似双向数据绑定12345678910&lt;form className=&quot;p-5&quot; onSubmit=&#123;this.handSubmit&#125;&gt; &lt;input type=&quot;text&quot; className=&quot;form-control&quot; ref=&#123;(textInput) =&gt;&#123; this.textInput = textInput &#125;&#125; /&gt; &lt;button className=&quot;btn btn-primary&quot;&gt;留言&lt;/button&gt;&lt;/form&gt; handSubmit(event)&#123;this.props.onAddData(this.textInput.value)event.preventDefault()//阻止默认事件&#125; 当点击提交的时候调用 onAddData(event) 函数,然后在主页面绑定函数123456789101112construct(props)&#123;this.state = &#123; comments:[&apos;信息&apos;]&#125;this.onAddData = this.onAddData.bind(this)&#125;addComment(comment) &#123; this.setState(&#123; comments:[...this.state.comments,comment] &#125;)&#125;... es6 函数方法 表示在旧的之后面追加新的值 contextprops 是由上到下的单向传递Context 提供了在组件中共享此类值的方法]]></content>
      <categories>
        <category>前端框架</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React初体验]]></title>
    <url>%2Faitao%2F2018%2F11%2F05%2FReact%E5%88%9D%E4%BD%93%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[React是一个JavaScript库,可以在浏览器运行，也可以在服务器运行,初次使用可以部署到本地测试，也可以直接使用codepen; 安装官方git地址1、拷贝库到本地 1git clone git@github.com:facebook/react.git 当然没有git可以直接下载压缩包解压到本地即可，关于git安装可以看看这篇： 模版React 独有的 JSX 语法，跟 JavaScript 不兼容。凡是使用 JSX 的地方，都要加上 type=”text/babel”1&lt;script type=&quot;text/babel&quot;&gt;&lt;/script&gt; ReactDOM.render()ReactDOM.render 是 React 的最基本方法，用于将模板转为 HTML 语言，并插入指定的 DOM 节点。12345&lt;div id=&quot;demo&quot;&gt;&lt;/div&gt;ReactDOM.render( &lt;h1&gt;你好，陌生人！&lt;/h1&gt; document.getElementById(&apos;demo&apos;);); JSX 语法允许 HTML 与 JavaScript 的混写遇到 HTML 标签（以 &lt; 开头），就用 HTML 规则解析；遇到代码块（以 { 开头），就用 JavaScript 规则解析。 12345678910111213141516171819202122232425262728293031&lt;div id=&quot;root&quot;&gt;&lt;/div&gt;var arr = [&apos;java&apos;,&apos;php&apos;,&apos;react&apos;];ReactDOM.render( &lt;div&gt; &#123; arr.map(function(value)&#123; return &lt;div&gt;我喜欢&#123;value&#125;&lt;/div&gt; &#125;) &#125; &lt;/div&gt;, //注意这儿有个逗号，每次分段都要有逗号分割 document.getElementById(&apos;root&apos;) //注意这儿没有逗号);当直接使用数组变量时就会将所有的变量顺序展示&lt;div&gt;我喜欢&#123;arr&#125;&lt;/div&gt;--&gt;我喜欢,javaphpreact也可以使用表达式 例如var element = (&lt;div&gt; &#123; arr.map(function(value)&#123; return &lt;div&gt;我喜欢&#123;value&#125;&lt;/div&gt; &#125;) &#125;&lt;/div&gt;);ReactDOM.render( element, document.getElementById(&apos;root&apos;)); 组件React 允许将代码封装成组件（component），然后像插入普通 HTML 标签一样，在网页中插入这个组件。React.createClass 方法就用于生成一个组件类注意，组件类的第一个字母必须大写，否则会报错，比如HelloMessage不能写成helloMessage。另外，组件类只能包含一个顶层标签，否则也会报错. 使用JavaScript函数1234567function Demo(props) &#123; return &lt;h1&gt;你好,&#123;props.name&#125;&lt;/h1&gt;;&#125;ReactDOM.render( &lt;Demo name=&quot;zhang&quot;/&gt;, document.getElementById(&apos;root&apos;)); 使用ES6 class来定义一个组件123456789class Demo extends React.Component &#123; render() &#123; return &lt;h1&gt;Hello, &#123;this.props.name&#125;&lt;/h1&gt;; &#125;&#125;ReactDOM.render( &lt;Demo name=&quot;陌生人！&quot;/&gt;, document.getElementById(&apos;root&apos;)); 写法上有个地方需要注意1234567891011121314151617181920return &lt;h1&gt;Hello, &#123;this.props.name&#125;&lt;/h1&gt;;这个地方可以这样写return &lt;h1&gt; Hello, &#123;this.props.name&#125;&lt;/h1&gt;;但不可以这样写return &lt;h1&gt; Hello, &#123;this.props.name&#125;&lt;/h1&gt;;并且可以这样写return &lt;div&gt; &lt;h1&gt;Hello, &#123;this.props.name&#125;&lt;/h1&gt; &lt;p&gt;你的笑像一条恶犬，撞乱了我的心弦！&lt;/p&gt;&lt;/div&gt;;但不可以这样写return &lt;div&gt; &lt;h1&gt;Hello, &#123;this.props.name&#125;&lt;/h1&gt;&lt;/div&gt;&lt;p&gt;你的笑像一条恶犬，撞乱了我的心弦！&lt;/p&gt;; 组件组合12345678910111213141516171819class Welcome extends React.Component &#123; render() &#123; return &lt;button&gt;Hello, &#123;this.props.name&#125;&lt;/button&gt;; &#125;&#125;class Demo extends React.Component &#123; render() &#123; return &lt;div&gt; &lt;Welcome name=&quot;I&quot; /&gt;, &lt;Welcome name=&quot;Love&quot; /&gt;, &lt;Welcome name=&quot;You&quot; /&gt;, &lt;/div&gt;; &#125;&#125;ReactDOM.render( &lt;Demo /&gt;, document.getElementById(&apos;root&apos;)); 所有的React组件必须像纯函数那样使用它们的props 真实dom节点的获取组件并不是真实的 DOM 节点，而是存在于内存之中的一种数据结构，叫做虚拟 DOM （virtual DOM）。只有当它插入文档以后，才会变成真实的 DOM 。根据 React 的设计，所有的 DOM 变动，都先在虚拟 DOM 上发生，然后再将实际发生变动的部分，反映在真实 DOM上，这种算法叫做 DOM diff ，它可以极大提高网页的性能表现。 但是，有时需要从组件获取真实 DOM 的节点，这时就要用到 ref 属性。123456789101112131415161718var MyComponent = React.createClass(&#123; handleClick: function() &#123; this.refs.myTextInput.focus(); &#125;, render: function() &#123; return ( &lt;div&gt; &lt;input type=&quot;text&quot; ref=&quot;myTextInput&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;Focus the text input&quot; onClick=&#123;this.handleClick&#125; /&gt; &lt;/div&gt; ); &#125;&#125;);ReactDOM.render( &lt;MyComponent /&gt;, document.getElementById(&apos;example&apos;)); stateReact 的一大创新，就是将组件看成是一个状态机，一开始有一个初始状态，然后用户互动，导致状态变化，从而触发重新渲染 UI1234567891011121314151617181920212223var LikeButton = React.createClass(&#123; getInitialState: function() &#123; return &#123;liked: false&#125;; &#125;, //定义初始状态，也就是一个对象，这个对象可以通过 this.state 属性读取。 handleClick: function(event) &#123; this.setState(&#123;liked: !this.state.liked&#125;); &#125;, //当用户点击组件，导致状态变化，this.setState 方法就修改状态值，每次修改以后，自动调用 this.render 方法，再次渲染组件 render: function() &#123; var text = this.state.liked ? &apos;like&apos; : &apos;haven\&apos;t liked&apos;; return ( &lt;p onClick=&#123;this.handleClick&#125;&gt; You &#123;text&#125; this. Click to toggle. &lt;/p&gt; ); &#125;&#125;);ReactDOM.render( &lt;LikeButton /&gt;, document.getElementById(&apos;example&apos;));this.props 表示那些一旦定义，就不再改变的特性，而 this.state 是会随着用户互动而产生变化的特性。 表单用户在表单填入的内容，属于用户跟组件的互动，所以不能用 this.props 读取以下为非受控表单1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768class NameForm extends React.Component &#123; constructor(props)&#123; super(props); this.state = &#123;name: &apos;&apos;,hobby: &apos;&apos;,introduce:&apos;&apos;,book: &apos;&apos;&#125;; this.handleChangeName = this.handleChangeName.bind(this); this.handleChangeHobby = this.handleChangeHobby.bind(this); this.handleChangeIntroduce = this.handleChangeIntroduce.bind(this); this.handleChangeBook = this.handleChangeBook.bind(this); this.handleSubmit = this.handleSubmit.bind(this); &#125; handleChangeName(event) &#123; this.setState(&#123; name:event.target.value &#125;); &#125; handleChangeHobby(event) &#123; this.setState(&#123; hobby:event.target.value &#125;); &#125; handleChangeIntroduce(event) &#123; this.setState(&#123; introduce: event.target.value &#125;) &#125; handleChangeBook(event) &#123; this.setState(&#123; book: event.target.value &#125;) &#125; handleSubmit(event) &#123; console.log(this.state); event.preventDefault(); &#125; render() &#123; return ( &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt; &lt;label&gt; 姓名: &lt;input type=&quot;text&quot; value=&#123;this.state.name&#125; onChange=&#123;this.handleChangeName&#125; /&gt; &lt;/label&gt; &lt;label&gt; 爱好: &lt;input type=&quot;text&quot; value=&#123;this.state.hobby&#125; onChange=&#123;this.handleChangeHobby&#125; /&gt; &lt;/label&gt; &lt;label&gt; 个人简介: &lt;textarea value=&#123;this.state.introduce&#125; onChange=&#123;this.handleChangeIntroduce&#125; &gt;&lt;/textarea&gt; &lt;/label&gt; &lt;label&gt; 喜欢的书 &lt;select value=&#123;this.state.value&#125; onChange=&#123;this.handleChangeBook&#125;&gt; &lt;option value=&quot;1&quot;&gt;Java&lt;/option&gt; &lt;option value=&quot;2&quot;&gt;PHP&lt;/option&gt; &lt;option value=&quot;3&quot;&gt;JavaScript&lt;/option&gt; &lt;option value=&quot;4&quot;&gt;Css&lt;/option&gt; &lt;/select&gt; &lt;/label&gt; &lt;input type=&quot;submit&quot; value=&quot;确定&quot; /&gt; &lt;/form&gt; ) &#125;&#125;ReactDOM.render( &lt;NameForm /&gt;, document.getElementById(&apos;root&apos;)); 非受控组件由于非受控组件将真实数据保存在 DOM 中，因此在使用非受控组件时，更容易同时集成 React 和非 React 代码。如果你想快速而随性，这样做可以减小代码量。否则，你应该使用受控组件。 拉个官网的栗子1234567891011121314151617181920212223class NameForm extends React.Component &#123; constructor(props) &#123; super(props); this.handleSubmit = this.handleSubmit.bind(this); &#125; handleSubmit(event) &#123; alert(&apos;A name was submitted: &apos; + this.input.value); event.preventDefault(); &#125; render() &#123; return ( &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt; &lt;label&gt; Name: &lt;input type=&quot;text&quot; ref=&#123;(input) =&gt; this.input = input&#125; /&gt; &lt;/label&gt; &lt;input type=&quot;submit&quot; value=&quot;Submit&quot; /&gt; &lt;/form&gt; ); &#125;&#125; 组件的生命周期组件的生命周期分成三个状态：123Mounting：已插入真实 DOMUpdating：正在被重新渲染Unmounting：已移出真实 DOM React 为每个状态都提供了两种处理函数，will 函数在进入状态之前调用，did 函数在进入状态之后调用，三种状态共计五种处理函数。 React 还提供两种特殊状态的处理函数。12componentWillReceiveProps(object nextProps)：已加载组件收到新的参数时调用shouldComponentUpdate(object nextProps, object nextState)：组件判断是否重新渲染时调用 123456789101112131415161718192021222324252627282930class Welcome extends React.Component&#123; constructor(props)&#123; super(props); this.state = &#123;opacity: 1.0&#125;; &#125; componentDidMount() &#123; this.timer = setInterval(function () &#123; var opacity = this.state.opacity; opacity -= .05; if (opacity &lt; 0.1) &#123; opacity = 1.0; &#125; this.setState(&#123; opacity: opacity &#125;); &#125;.bind(this), 100); &#125; render() &#123; return ( &lt;div style=&#123;&#123;opacity: this.state.opacity&#125;&#125;&gt; Hello &#123;this.props.name&#125; &lt;/div&gt; ); &#125;&#125;;ReactDOM.render( &lt;Welcome name=&quot;world&quot;/&gt;, document.getElementById(&apos;root&apos;));]]></content>
      <categories>
        <category>前端框架</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[layx初体验]]></title>
    <url>%2Faitao%2F2018%2F11%2F03%2Flayx%E5%88%9D%E4%BD%93%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[Layx 新一代Web弹窗组件，纯原生Javascript实现，不依赖任何第三方框架git 地址： 初次使用第一步：引入 layx.css / layx.min.css 第二步：引入 layx.js / layx.min.js 第三步：打开一个窗口试试layx.html(‘str’,’字符串文本’,’Hello Layx!’); 消息提示1layx.msg('2419 iaitao',&#123;dialogIcon:'success'&#125;);//成功提示 dialogIcon: 提示图标相关如下success：成功图标warn：警告图标error：错误图标help: 帮助图标 窗口皮肤123456789101112layx.msg( '2419 iaitao', &#123; dialogIcon:'success', skin:'cloud' &#125;);//成功提示参数default // 默认有边框cloud // 白色turquoise //青绿色river //蓝色asphalt // 沥青色 提示窗口12layx.alert('操作提示','2419 i aitao！');//提示窗口layx.alert('操作提示','2419 i aitao！',null,&#123;dialogIcon:'success'&#125;);//提示窗口 添加提示图标 打开网页1layx.iframe('localsite','网页打开测试','https://www.baidu.com'); 添加提示方向 ： top 、right、bottom、left1234&lt;a href="#" id="tip-right"&gt;测试&lt;/a&gt;&lt;script type="text/javascript"&gt; layx.tip('只是测试哦.',document.getElementById('tip-right'),'right');&lt;/script&gt; 询问窗口123456789101112131415161718192021222324252627282930layx.confirm('选择','你会选择爱情而放弃事业吗？',function(id)&#123; layx.msg('你的选择是正确的',&#123;dialogIcon:'success'&#125;);//成功提示 layx.destroy(id);&#125;);带图标layx.confirm('选择','你会选择爱情而放弃事业吗？',function(id)&#123; layx.msg('你的选择是正确的',&#123;dialogIcon:'success'&#125;);//成功提示 layx.destroy(id);&#125;,&#123;dialogIcon:'success'&#125;);双向选择layx.confirm('选择','你会选择爱情而放弃事业吗？',null,&#123; buttons:[ &#123; label:'是的', callback:function(id, button, event)&#123; layx.msg('你的选择是正确的,爱情价更高！',&#123;dialogIcon:'success'&#125;);//成功提示 layx.destroy(id); &#125; &#125;, &#123; label:'不会', callback:function(id, button, event)&#123; layx.msg('你的选择是正确的,爱情不能盲目！',&#123;dialogIcon:'success'&#125;);//成功提示 layx.destroy(id); &#125; &#125; ]&#125;,&#123;dialogIcon:'success'&#125;); 加载等待1234567891011layx.load('loadId','数据正在加载中，请稍后');// 5 秒后自动关闭setTimeout(function()&#123; layx.destroy('loadId');&#125;,5000);倒计时窗口layx.iframe('settimeout','打开一个倒计时关闭窗口','https://www.baidu.com',&#123; autodestroy:5000&#125;); 打开窗口和窗口组初始化 窗口宽度：800 高度：600 minWidth：200 minHeight：200，宽度高度支持百分比显示，窗口位置 默认正中间 窗口组12345678910111213141516171819202122232425262728293031layx.group('group',[ &#123; id:'group1', title:'文本窗口', content:'Layx 新一代Web弹窗组件.', bgColor:'#ccc', &#125;, &#123; id:'group2', title:'网页窗口', type:'url', url:'./iframe.html' &#125;, &#123; id:'taobao', title:'百度官网', type:'url', url:'https://www.baidu.com' &#125;],0,&#123; width:600, skin:'cloud', mergeTitle:false, title:'你好呀，我是标题~'&#125;));0 表示默认显示第一个窗口 下标从0开始bgColor 表示页面背景颜色如果需要显示标题就添加下面两个参数，不需要就不用加 mergeTitle:false, title:'你好呀，我是标题~' 遮罩窗口123456789101112131415layx.iframe('shadow','打开一个遮罩、阻隔窗口，点击窗口外试试','http://www.baidu.com',&#123; shadable:true&#125;);shadable 透明度 取值0~1 浮点值 透明度依次递减点击空白地方关闭layx.iframe('shadow-click','点击阻隔空白地方关闭窗口','http://www.baidu.com',&#123; shadable:0.2, control:true, border:false, shadow:false, shadeDestroy:true // 点击空白地方关闭&#125;);control 设置 false 将不显示控制标题栏，同时窗口拖动功能失效，需手动调用关闭方法关闭窗口。border:false 表示无边框 自定义样式123456789101112131415161718layx.iframe('radiu-style','自定义外观，比如圆角','./iframe.html',&#123; style:layx.multiLine(function()&#123;/* icon:false, #layx-radiu-style&#123; border-radius:4px; -webkit-border-radius:4px; -moz-border-radius:4px; -ms-border-radius:4px; &#125; #layx-radiu-style .layx-window-icon&#123; color:#f00; &#125;*/&#125;)&#125;);icon 打开窗口的图标，可以去掉也可以自定义例如：icon:'&lt;img src="http://img.zcool.cn/community/019c2958a2b760a801219c77a9d27f.jpg" style="height:22px;display:block;" /&gt;', 关闭窗口12parent.layx.destroy(id); // 方法一（推荐）top.layx.destroy(id); // 方法二]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Layx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[thinkphp标签循环嵌套]]></title>
    <url>%2Faitao%2F2018%2F11%2F02%2Fthinkphp%E6%A0%87%E7%AD%BE%E5%BE%AA%E7%8E%AF%E5%B5%8C%E5%A5%97%2F</url>
    <content type="text"><![CDATA[thinkphp volist 多重循环嵌套key]]></content>
  </entry>
  <entry>
    <title><![CDATA[Jquery对input的一些操作]]></title>
    <url>%2Faitao%2F2018%2F11%2F02%2FJquery%E5%AF%B9input%E7%9A%84%E4%B8%80%E4%BA%9B%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[场景：对于选中，选择的一些操作，比如：勾选导出，获得全部选中的值等等 获得全部选中的值html 部分代码：1234567&lt;div class="checkbox"&gt; &lt;label&gt; &lt;input type="checkbox" name="ids[]" value="1"&gt; &lt;span class="text"&gt;&lt;/span&gt; &lt;/label&gt; ......&lt;/div&gt; javascript 代码：1234567891011121314function getAllValue()&#123; var ids = new Array(); i = 0; $("input[name^='ids']:checked").each(function()&#123;//找到所有被选中的值 var val = $(this).val(); ids[i] = val; i++; &#125;); var len = ids.length; if(len === 0)&#123; return false; &#125; return ids;&#125; 勾选多项进行操作$.getJSON 简介：JSON（JavaScript Object Notation）即JavaScript对象表示法，是一种轻量级的数据交换格式。它非常便于编程人员对数据的处理，也便于机器对数据的解析和生成，应用非常广泛。json文件可以保存为“test.json”这样的文件，json数据的一般格式如下（“{ }”中的为对象，“[ ]”中的为数组)123456789101112131415function operate()&#123; var url = $(this).attr('url');//获得操作使用的url地址 var ids = getAllValue();//调用上列使用的方法 if(!ids)&#123; return false; &#125; $.getJSON(url,&#123;'t':new Date().getTime()&#125;,function(d)&#123; //发送get请求 返回结构比如：['status'=&gt;1|0,'data'=&gt;[],'msg'=&gt;'ok'] if(d.status&gt;0)&#123; alert(d.msg);//成功信息 &#125;else&#123; alert(d.msg);//失败信息 &#125; &#125;&#125; 反选操作html 示例12345678910111213&lt;div&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt; &lt;label&gt; &lt;input type="checkbox" name="ids[]" value="1"&gt; &lt;span class="text"&gt;&lt;/span&gt; &lt;/label&gt; &lt;/td&gt; &lt;/tr&gt; ...... &lt;/table&gt;&lt;/div&gt; JavaScript 示例1234567891011121314$('.reverse-select').on('click',function()&#123;//反选 class="reverse-select" var is_check = $(this).prop('checked'); $(this).parents('table').find("input[name^='ids']").each(function()&#123; //查找节点遍历 也可使用 $("table input[name^='ids']").each(); var has_check = $(this).prop('checked'); if(is_check &amp;&amp; !has_check)&#123; $(this).prop('checked',true); &#125;else&#123; if(has_check &amp;&amp; !is_check)&#123; $(this).prop('checked',false); &#125; &#125; &#125;&#125;)]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Jquery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP常用字符串总结]]></title>
    <url>%2Faitao%2F2018%2F11%2F02%2FPHP%E5%B8%B8%E7%94%A8%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[PHP 是 “PHP Hypertext Preprocessor” 的首字母缩略词PHP 是一种被广泛使用的开源脚本语言PHP 脚本在服务器上执行PHP 没有成本，可供免费下载和使用 PHP 相关主流框架：thinkphp5.0 看云文档 laravel 中文社区 Phalcon Symfony 排列不分先后。 本文对框架不做讨论 常用字符串函数及使用字符串大小写转换12345$str = 'abc';$low_str = strtolower($str);echo '转换为小写'+$low_str;$uper_str = strtoupper($str);echo '转换为大写'+$uper_str; 替换字符串中的字串1.mixed substr_replace ( mixed $string , mixed $replacement , mixed $start [, mixed $length ] )substr_replace()在字符串 string 的副本中将由 start 和可选的 length 参数限定的子字符串使用 replacement 进行替换。注： 如果 start 为正数，替换将从 string 的 start 位置开始。 如果 start 为负数，替换将从 string 的倒数第 start 个位置开始。 1234实列：$str = 'abc';$new_str = substr_replace($str,'d',0,$strlen($str));//strlen() 函数计算字符串的长度echo '新的字串的值'+$new_str;//abcd strtr()12echo strtr("Hilla Warld","ia","eo");Hello World More info: php 文档 字符串与数组之间的相互转化array explode ( string $delimiter , string $string [, int $limit ] )此函数返回由字符串组成的数组，每个元素都是 string 的一个子串，它们被字符串 delimiter 作为边界点分割出来。string implode ( string $glue , array $pieces ) //$glue 默认为空字符串string implode ( array $pieces )implode() 可以接收两种参数顺序，但是 explode() 不行。 12345678910111213实例：$str = 'a,b,c,d';//逗号为分隔字符 相当于 $delimiter ='';$arr = explode(',',$str);dump($arr);得到：array(4) &#123; [0] =&gt; string(1) "a" [1] =&gt; string(1) "b" [2] =&gt; string(1) "c" [3] =&gt; string(1) "d"&#125;$new_str = implode($arr);echo $new_str;//abcd]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一篇文章 localStorage 存储]]></title>
    <url>%2Faitao%2F2018%2F11%2F01%2F%E5%AD%98%E5%82%A8%2F</url>
    <content type="text"><![CDATA[多项表单 localStorage 存储适用于多项输入如：radio 、text 、 number12345678910111213141516171819202122232425262728293031323334$(function()&#123; //页面初始加载判断缓存 var lenth = localStorage.length; if(lenth !='' &amp;&amp; lenth !=undefined &amp;&amp; lenth != null) &#123; for(var i= lenth - 1 ; i &gt;0; i--)&#123; var key = localStorage.key(i);//缓存的key var val = localStorage.getItem(key);//缓存的值 var name = key.substring(0,key.length -2);//获得缓存位置的名称 var distinguish = key.substring(key.length -2,key.length); //取的识别字符 if(distinguish === '4a')&#123; $("input[type='radio']").each(function () &#123; if($(this)[0].name === name &amp;&amp; $(this)[0].value === val)&#123; $(this).attr('checked', true); &#125; &#125;); $("input[type='text']").each(function () &#123; if($(this)[0].name === name )&#123; $(this).val(val) &#125; &#125;); &#125; &#125; &#125; &#125;) //监听内容变化 $("input[type='text']").bind("input propertychange",function (event) &#123; localStorage.setItem(event.target.name+'4a', event.target.value); &#125;); $("input[type='radio']").on('input', function(event) &#123; localStorage.setItem(event.target.name+'4a', event.target.value); //设置缓存 名字+识别字符 &#125;);]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Html</tag>
      </tags>
  </entry>
</search>
